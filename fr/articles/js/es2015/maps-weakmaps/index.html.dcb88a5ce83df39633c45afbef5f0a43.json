{"head":{"layout":"Post","comments":true,"date":"2015-12-11","title":"ES6, ES2015 : les Maps & WeakMaps","tags":["javascript","ES6","ES2015"],"authors":["bloodyowl"],"description":"Maps Comme les objets, les maps et weak maps introduites avec ES6 sont des dictionnaires. La différence avec un objet, c'est que n'importe…"},"body":"<h2 id=\"maps\"><a href=\"#maps\"></a>Maps</h2>\n<p>Comme les objets, les maps et weak maps introduites avec ES6 sont des dictionnaires. La différence avec un objet, c'est que n'importe quelle valeur peut être utilisée comme clé.</p>\n<pre><code class=\"language-javascript\">const myMap = new Map()\nmyMap.set(window, 1)\nmyMap.get(window) // 1\n</code></pre>\n<p>Pour créer une map avec des valeurs, on peut passer un tableau de clés/valeurs en argument :</p>\n<pre><code class=\"language-javascript\">const myMap = new Map([\n  [ 1, \"foo\" ],\n  [ window, \"bar\" ],\n])\n</code></pre>\n<p>Pour tester si une clé est présente, on peut utiliser la méthode <code>has</code> :</p>\n<pre><code class=\"language-javascript\">map.has(1) // false\n</code></pre>\n<p>On peut itérer sur les entrées d'une map à l'aide de <code>forEach</code> :</p>\n<pre><code class=\"language-javascript\">const myMap = new Map([\n  [ 1, \"foo\" ],\n  [ window, \"bar\" ],\n])\n\nmyMap.forEach((value, key) => {\n    // do something\n})\n</code></pre>\n<p>On peut aussi itérer à l'aide du <code>for … of</code> :</p>\n<pre><code class=\"language-javascript\">for (const [key, value] of myMap) {\n  console.log(key, value)\n}\n</code></pre>\n<p>Ainsi que convertir la map en tableau à l'aide du spread, puisqu'une map est itérable :</p>\n<pre><code class=\"language-javascript\">const myEntries = [...myMap] // […[key, value]]\nconst myEntries = [...myMap.entries()] // alternativement\n</code></pre>\n<p>On peut aussi récupérer des itérables par clés et valeurs :</p>\n<pre><code class=\"language-javascript\">const myKeys = [...myMap.keys()]\nconst myValues = [...myMap.values()]\n</code></pre>\n<p>Particularité, la valeur <code>NaN</code>, qui en JS n'est pas égale à elle même, est bien gérée :</p>\n<pre><code class=\"language-javascript\">myMap.set(NaN, 1)\nmyMap.get(NaN) // 1\n</code></pre>\n<p>Une utilisation possible des Maps est la fonction <code>dedupe</code> pour éliminer les doublons d'un array :</p>\n<pre><code class=\"language-javascript\">const dedupe = (array) => {\n  return [...new Map(array.map((item) => [item, true])).keys()]\n}\n\ndedupe([1, 1, 2, 3, 4, 4]) // [1, 2, 3, 4]\n</code></pre>\n<h2 id=\"weakmaps\"><a href=\"#weakmaps\"></a>WeakMaps</h2>\n<p>Les WeakMaps sont comme les Maps mais qui ne gardent pas les valeurs \"oubliées\". Le garbage collector ne tient donc pas compte des weak maps.</p>\n<p>Les WeakMaps ne possèdent pas de méthodes d'itération et n'acceptent pas de valeurs primitives comme clés.</p>\n<pre><code class=\"language-javascript\">const myWeakMap = new WeakMap()\nmyWeakMap.set(1, 1) // TypeError\n</code></pre>\n<pre><code class=\"language-javascript\">const myWeakMap = new WeakMap()\nmyWeakMap.set(window, 1)\n(() => {\n  const object = {}\n  myWeakMap.set(object, 2)\n})()\n// myWeakMap a oublié la valeur 2, car `object` n'est plus accessible\n// seule la clé `window` persiste.\n</code></pre>\n<p>Un usage possible est le stockage d'informations lié à une instance de classe, permettant de \"cacher\" cette information de l'instance :</p>\n<pre><code class=\"language-javascript\">const callbacks = new WeakMap()\n\nclass SimpleEventEmitter {\n  constructor() {\n    callbacks.set(this, [])\n  }\n  addEventListener(callback) {\n    callbacks.set(this, callbacks.get(this).concat(callback))\n  }\n  removeEventListener(callback) {\n    callbacks.set(this, callbacks.get(this)\n      .filter((func) => func !== callback))\n  }\n  triggerEvent(...args) {\n    callbacks.get(this).forEach((func) => func(...args))\n  }\n}\n</code></pre>\n","rawBody":"\n## Maps\n\nComme les objets, les maps et weak maps introduites avec ES6 sont des dictionnaires. La différence avec un objet, c'est que n'importe quelle valeur peut être utilisée comme clé.\n\n```javascript\nconst myMap = new Map()\nmyMap.set(window, 1)\nmyMap.get(window) // 1\n```\n\nPour créer une map avec des valeurs, on peut passer un tableau de clés/valeurs en argument :\n\n```javascript\nconst myMap = new Map([\n  [ 1, \"foo\" ],\n  [ window, \"bar\" ],\n])\n```\n\nPour tester si une clé est présente, on peut utiliser la méthode `has` :\n\n```javascript\nmap.has(1) // false\n```\n\nOn peut itérer sur les entrées d'une map à l'aide de `forEach` :\n\n```javascript\nconst myMap = new Map([\n  [ 1, \"foo\" ],\n  [ window, \"bar\" ],\n])\n\nmyMap.forEach((value, key) => {\n\t// do something\n})\n```\n\nOn peut aussi itérer à l'aide du `for … of` :\n\n```javascript\nfor (const [key, value] of myMap) {\n  console.log(key, value)\n}\n```\n\nAinsi que convertir la map en tableau à l'aide du spread, puisqu'une map est itérable :\n\n```javascript\nconst myEntries = [...myMap] // […[key, value]]\nconst myEntries = [...myMap.entries()] // alternativement\n```\n\nOn peut aussi récupérer des itérables par clés et valeurs :\n\n```javascript\nconst myKeys = [...myMap.keys()]\nconst myValues = [...myMap.values()]\n```\n\nParticularité, la valeur `NaN`, qui en JS n'est pas égale à elle même, est bien gérée :\n\n```javascript\nmyMap.set(NaN, 1)\nmyMap.get(NaN) // 1\n```\n\nUne utilisation possible des Maps est la fonction `dedupe` pour éliminer les doublons d'un array :\n\n\n```javascript\nconst dedupe = (array) => {\n  return [...new Map(array.map((item) => [item, true])).keys()]\n}\n\ndedupe([1, 1, 2, 3, 4, 4]) // [1, 2, 3, 4]\n```\n\n## WeakMaps\n\nLes WeakMaps sont comme les Maps mais qui ne gardent pas les valeurs \"oubliées\". Le garbage collector ne tient donc pas compte des weak maps.\n\nLes WeakMaps ne possèdent pas de méthodes d'itération et n'acceptent pas de valeurs primitives comme clés.\n\n```javascript\nconst myWeakMap = new WeakMap()\nmyWeakMap.set(1, 1) // TypeError\n```\n\n```javascript\nconst myWeakMap = new WeakMap()\nmyWeakMap.set(window, 1)\n(() => {\n  const object = {}\n  myWeakMap.set(object, 2)\n})()\n// myWeakMap a oublié la valeur 2, car `object` n'est plus accessible\n// seule la clé `window` persiste.\n```\n\nUn usage possible est le stockage d'informations lié à une instance de classe, permettant de \"cacher\" cette information de l'instance :\n\n```javascript\nconst callbacks = new WeakMap()\n\nclass SimpleEventEmitter {\n  constructor() {\n    callbacks.set(this, [])\n  }\n  addEventListener(callback) {\n    callbacks.set(this, callbacks.get(this).concat(callback))\n  }\n  removeEventListener(callback) {\n    callbacks.set(this, callbacks.get(this)\n      .filter((func) => func !== callback))\n  }\n  triggerEvent(...args) {\n    callbacks.get(this).forEach((func) => func(...args))\n  }\n}\n```\n","raw":"---\ndate: \"2015-12-11\"\ntitle: \"ES6, ES2015 : les Maps & WeakMaps\"\ntags:\n  - javascript\n  - ES6\n  - ES2015\nauthors:\n  - bloodyowl\n---\n\n## Maps\n\nComme les objets, les maps et weak maps introduites avec ES6 sont des dictionnaires. La différence avec un objet, c'est que n'importe quelle valeur peut être utilisée comme clé.\n\n```javascript\nconst myMap = new Map()\nmyMap.set(window, 1)\nmyMap.get(window) // 1\n```\n\nPour créer une map avec des valeurs, on peut passer un tableau de clés/valeurs en argument :\n\n```javascript\nconst myMap = new Map([\n  [ 1, \"foo\" ],\n  [ window, \"bar\" ],\n])\n```\n\nPour tester si une clé est présente, on peut utiliser la méthode `has` :\n\n```javascript\nmap.has(1) // false\n```\n\nOn peut itérer sur les entrées d'une map à l'aide de `forEach` :\n\n```javascript\nconst myMap = new Map([\n  [ 1, \"foo\" ],\n  [ window, \"bar\" ],\n])\n\nmyMap.forEach((value, key) => {\n\t// do something\n})\n```\n\nOn peut aussi itérer à l'aide du `for … of` :\n\n```javascript\nfor (const [key, value] of myMap) {\n  console.log(key, value)\n}\n```\n\nAinsi que convertir la map en tableau à l'aide du spread, puisqu'une map est itérable :\n\n```javascript\nconst myEntries = [...myMap] // […[key, value]]\nconst myEntries = [...myMap.entries()] // alternativement\n```\n\nOn peut aussi récupérer des itérables par clés et valeurs :\n\n```javascript\nconst myKeys = [...myMap.keys()]\nconst myValues = [...myMap.values()]\n```\n\nParticularité, la valeur `NaN`, qui en JS n'est pas égale à elle même, est bien gérée :\n\n```javascript\nmyMap.set(NaN, 1)\nmyMap.get(NaN) // 1\n```\n\nUne utilisation possible des Maps est la fonction `dedupe` pour éliminer les doublons d'un array :\n\n\n```javascript\nconst dedupe = (array) => {\n  return [...new Map(array.map((item) => [item, true])).keys()]\n}\n\ndedupe([1, 1, 2, 3, 4, 4]) // [1, 2, 3, 4]\n```\n\n## WeakMaps\n\nLes WeakMaps sont comme les Maps mais qui ne gardent pas les valeurs \"oubliées\". Le garbage collector ne tient donc pas compte des weak maps.\n\nLes WeakMaps ne possèdent pas de méthodes d'itération et n'acceptent pas de valeurs primitives comme clés.\n\n```javascript\nconst myWeakMap = new WeakMap()\nmyWeakMap.set(1, 1) // TypeError\n```\n\n```javascript\nconst myWeakMap = new WeakMap()\nmyWeakMap.set(window, 1)\n(() => {\n  const object = {}\n  myWeakMap.set(object, 2)\n})()\n// myWeakMap a oublié la valeur 2, car `object` n'est plus accessible\n// seule la clé `window` persiste.\n```\n\nUn usage possible est le stockage d'informations lié à une instance de classe, permettant de \"cacher\" cette information de l'instance :\n\n```javascript\nconst callbacks = new WeakMap()\n\nclass SimpleEventEmitter {\n  constructor() {\n    callbacks.set(this, [])\n  }\n  addEventListener(callback) {\n    callbacks.set(this, callbacks.get(this).concat(callback))\n  }\n  removeEventListener(callback) {\n    callbacks.set(this, callbacks.get(this)\n      .filter((func) => func !== callback))\n  }\n  triggerEvent(...args) {\n    callbacks.get(this).forEach((func) => func(...args))\n  }\n}\n```\n","__filename":"fr/articles/js/es2015/maps-weakmaps.md","__url":"/fr/articles/js/es2015/maps-weakmaps/","__resourceUrl":"/fr/articles/js/es2015/maps-weakmaps/index.html","__dataUrl":"/fr/articles/js/es2015/maps-weakmaps/index.html.dcb88a5ce83df39633c45afbef5f0a43.json"}