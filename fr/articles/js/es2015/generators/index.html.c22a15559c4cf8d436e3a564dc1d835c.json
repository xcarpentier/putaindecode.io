{"head":{"layout":"Post","comments":true,"date":"2015-12-10","title":"ES6, ES2015 : itérateurs et générateurs","tags":["JavaScript","ES6","ES2015"],"authors":["naholyr"],"description":"Un gros morceau aujourd'hui : les itérateurs et les fonctions qui les génèrent, appelées \"générateurs\". ES6/2015 apporte énormément de…"},"body":"<p>Un gros morceau aujourd'hui : les itérateurs et les fonctions qui les génèrent,\nappelées \"générateurs\".\nES6/2015 apporte énormément de \"sucres syntaxiques\", même s'ils sont\nterriblement pratiques. Les valeurs par défaut, l'affectation par\ndéstructuration, les fonctions flêchées…\nTout ça n'apporte pas de réelle nouvelle fonctionnalité.\nC'est un peu différent pour les générateurs qui vont permettre de prendre le\ncontrôle sur l'éxécution d'une fonction depuis l'extérieur.</p>\n<h2 id=\"fonction-en-pause\"><a href=\"#fonction-en-pause\"></a>Fonction \"en pause\"</h2>\n<p>Un nouveau mot-clé fait son apparition : <code>function*</code>, une fonction marquée par\nl'astérisque n'est jamais exécutée directement, à la place, elle retourne un\n<em>itérateur</em>. Un générateur est donc capable de s'interrompre (d'ailleurs, il\nl'est par défaut).\nIl est également capable de reprendre là où il s'était arrêté :\nl'itérateur retourné est un objet exposant une méthode  <code>next</code> qui\nlorsqu'elle est appelée demande au générateur de reprendre là où il en était.</p>\n<pre><code class=\"language-js\">function * idleFunction () {\n  console.log('World')\n}\n\nconst iterator = idleFunction()\n// L'exécution de la fonction est interrompue en attente d'être \"débloquée\"\nconsole.log('Hello')\niterator.next() // L'éxécution reprend et on affiche \"World\"\n</code></pre>\n<p>Notez qu'il ne s'agit pas de code <strong>bloquant</strong> : la fonction est mise en pause,\nson traitement sera repris plus tard, pendant ce temps l'<em>event-loop</em> continue\nsa petite vie.</p>\n<h2 id=\"reprise-du-traitement-et-émission-de-valeur-avec-yield\"><a href=\"#reprise-du-traitement-et-%C3%A9mission-de-valeur-avec-yield\"></a>Reprise du traitement et émission de valeur avec <code>yield</code></h2>\n<p>La méthode <code>next()</code> de l'itérateur retourne un objet possédant les propriétés\nsuivantes :</p>\n<ul>\n<li><code>done</code> vaut <code>true</code> quand le générateur a terminé son exécution</li>\n<li><code>value</code> est la valeur émise par le générateur dans cette portion de code</li>\n</ul>\n<p>Comment émettre une valeur ? Le mot-clé <code>yield</code> a le double rôle de fournir\nune valeur et de remettre en pause l'exécution de la fonction. Le principe étant\nqu'on va émettre <strong>plusieurs</strong> valeurs, sinon on utiliserait simplement\n<code>return</code>.</p>\n<pre><code class=\"language-js\">function * numbers () {\n  yield 1\n  yield 2\n}\n\nconst iterator = numbers()\niterator.next() // { value: 1, done: false }\niterator.next() // { value: 2, done: false }\niterator.next() // { value: undefined, done: true }\n</code></pre>\n<p>Note : si notre générateur <code>return</code> une valeur, elle sera affectée à la\npropriété <code>value</code> de la dernière itération.</p>\n<h3 id=\"use-case-listes-infinies\"><a href=\"#use-case-listes-infinies\"></a><em>Use case</em> : listes infinies</h3>\n<p>Un premier <em>use case</em> à ce stade est la possibilité de générer des listes de\nlongueur non définie à l'avance. On peut parcourir une suite dont on ne sait pas\nà l'avance <em>combien</em> d'éléments on veut, par exemple récupérer tous les éléments\nde la suite de Fibonacci inférieurs à 100 :</p>\n<pre><code class=\"language-js\">function * fibo () {\n  let [a, b] = [1, 1]\n  while (true) { // Who can stop me?\n    [a, b] = [b, a + b]\n    yield a\n  }\n}\n\nconst iterator = fibo()\nfor (let n of iterator) {\n  if (n >= 100) {\n    break // *I* can stop you\n  }\n  console.log(n)\n}\n// 1 2 3 5 8 13 21 34 55 89\n</code></pre>\n<p>Note : l'opérateur <code>for … of</code> sera vu plus en détail dans un prochain article.</p>\n<h2 id=\"passage-de-valeur-au-générateur\"><a href=\"#passage-de-valeur-au-g%C3%A9n%C3%A9rateur\"></a>Passage de valeur au générateur</h2>\n<p>On a vu que <code>yield</code> permettait d'émettre une valeur depuis le générateur vers\nle code contrôleur. Mais le sens inverse est également possible : la méthode\n<code>next</code> de l'itérateur accepte une valeur en paramètre, qui sera alors\nretournée par l'appel correspondant à <code>yield</code>. Exemple :</p>\n<pre><code class=\"language-js\">function * math () {\n  // Le premier appel à next() permet de \"démarrer\" le générateur\n  const x = yield // la valeur de la première itération sera undefined\n  // x = le paramètre du second appel à next()\n  const y = yield x + 1 // valeur de la seconde itération : x + 1\n  // y = paramètre du troisième appel à next()\n  yield y // valeur de la troisième itération : y\n  // le 4e appel (et +) à next() retournent { value: undefined, done: true }\n}\n\nconst iterator = math()\niterator.next(42) // { value: undefined, done: false }\n// Passer un paramètre au premier appel à next() n'est pas utile : cette valeur\n// n'est pas accessible dans le générateur car aucun \"yield\" correspondant\n\niterator.next(33) // { value: 34, done: false }, x = 33 dans le générateur\niterator.next(27) // { value: 27, done: false }, y = 27 dans le générateur\niterator.next() // { value: undefined, done: true }\n</code></pre>\n<p>Ça ne semble pas très utile vu comme ça, mais on peut passer à <code>next()</code>\nn'importe quel type de donnée : une fonction, un objet, un autre itérateur… Les\npossibilités sont infinies. On va en explorer une rapidement avec les promesses.</p>\n<h3 id=\"use-case-co-routines\"><a href=\"#use-case-co-routines\"></a><em>Use case</em> : co-routines</h3>\n<p>Le code du générateur lui-même ne peut être réellement asynchrone : les appels à\n<code>yield</code> se suivent de manière synchrone. Le code contrôleur par contre, est\nlibre d'appeler <code>next()</code> à loisir, et peut donc le faire de manière asynchrone.</p>\n<p>On a donc des fonctions dont on peut choisir quand elles sont interrompues, et\nquand elles peuvent reprendre leur traitement. Et si… notre générateur émettait\ndes promesses ? Histoire d'expliquer à son code contrôleur <em>quand</em> il est sûr de\nreprendre le traitement. Et si ce code contrôleur, voyant qu'il récupère une\npromesse, attendait que cette dernière soit résolue pour transmettre au\ngénérateur en retour la valeur résolue ? Dans ce cas le générateur pourrait\ndisposer de manière <strong>synchrone</strong> mais <strong>non bloquante</strong> de résultats de\ntraitements asynchrones :</p>\n<pre><code class=\"language-js\">execAsync(function * () {\n  console.log(\"Ajax request…\")\n  var rows = yield fetch(\"http://my.api/get\")\n  console.log(\"Work…\")\n  console.log(\"Save…\")\n  yield fetch(\"http://my.api/post\")\n  console.log(\"OK.\")\n}) // Ajax request… Work… Save… OK.\n</code></pre>\n<p>Ne serait-ce pas merveilleux ? C'est le <em><em>use case</em></em> le plus intéressant pour\nnous au quotidien, et c'est assez simple en fait :</p>\n<pre><code class=\"language-js\">function execAsync (promiseGenerator) {\n  const iter = promiseGenerator() // en pause…\n\n  function loop (iteration) {\n    if (iteration.done) { // Le générateur a return'é, fin du game\n      return iteration.value\n    }\n\n    // c'est un générateur de promesse, dont on attend la résolution ici\n    return iteration.value.then(result => {\n      // La promesse est résolue, on peut repasser sa valeur au générateur\n      const nextIteration = iter.next(result) // cette valeur est return'ée par\n      // le même \"yield\" qui a émis la promesse, ça tombe bien :)\n\n      // Puis on relance notre boucle, et on continue récursivement\n      return next(nextIteration)\n    })\n  }\n\n  const promiseIteration = iter.next() // exécution reprise jusqu'au prochain \"yield\"\n  // le générateur est remis en pause jusqu'au prochain appel à \"iter.next\"\n\n  // Première itération de la boucle\n  return loop(promiseIteration)\n}\n</code></pre>\n<h2 id=\"more-more-more\"><a href=\"#more-more-more\"></a>More! more! more!</h2>\n<h3 id=\"gestion-derreur\"><a href=\"#gestion-derreur\"></a>Gestion d'erreur</h3>\n<p>Les erreurs, tout comme les valeurs, peuvent être émises dans les deux\ndirections. Le générateur peut <code>throw</code> vers le code contrôleur (le code est\nsynchrone) :</p>\n<pre><code class=\"language-js\">function * fail () {\n  yield 1\n  throw new Error('oops')\n  yield 2\n}\n\nconst iterator = fail()\niterator.next() // { value: 1, done: false }\ntry {\n  iterator.next() // throws\n} catch (e) {\n  e // Error('oops')\n}\n</code></pre>\n<p>Mais le code contrôleur peut également émettre une erreur vers le générateur\navec la méthode <code>throw</code> de l'itérateur :</p>\n<pre><code class=\"language-js\">function * fail () {\n  try {\n    yield 1\n  } catch (e) {\n    console.error(e)\n  }\n  yield 2\n}\n\nconst iterator = fail()\niterator.next() // { value: 1, done: false }\niterator.throw(new Error(\"nope\")) // affiche \"[Error: nope]\"\niterator.next() // { value: 2, done: false }\niterator.next() // { value: undefined, done: true }\n</code></pre>\n<p>Note : il faut bien se souvenir que le premier <code>next</code> sert à <em>débloquer</em>\nl'exécution du générateur, qui va alors jusqu'au premier <code>yield</code>, évalue\nl'expression émise, la transmet en retour de <code>next()</code>, et remet la fonction en\npause. C'est au second <code>yield</code> seulement que l'exécution reprend <strong>à partir de\n<code>yield 1</code></strong>. C'est une partie que je trouve contre-intuitive et que j'ai eu du\nmal à assimiler.</p>\n<h3 id=\"délégation\"><a href=\"#d%C3%A9l%C3%A9gation\"></a>Délégation</h3>\n<p>L'opérateur <code>yield*</code> permet d'émettre les valeurs d'un autre itérateur, par\nexemple :</p>\n<pre><code class=\"language-js\">function * oneToThree () {\n  yield 1\n  yield 2\n  yield 3\n}\n\nfunction * zeroToFour () {\n  yield 0\n  yield * oneToThree()\n  yield 4\n}\n</code></pre>\n<p>Cela fonction bien sûr avec tous\n<a href=\"/fr/articles/js/es2015/iterators/\">les <em>itérables</em></a> :\n<code>yield * [1, 2, 3]</code> est valide par exemple.</p>\n<h3 id=\"retour-anticipé\"><a href=\"#retour-anticip%C3%A9\"></a>Retour anticipé</h3>\n<p>Il est possible de terminer le traitement d'un générateur depuis le code\ncontrôleur avec la méthode <code>return</code> de l'itérateur. Tout se passera comme si\nle générateur se terminait immédiatement avec la valeur de retour fournie.</p>\n<pre><code class=\"language-js\">function * numbers () {\n  yield 1\n  yield 2\n  yield 3\n}\n\nconst iterator = numbers()\niterator.next() // { value: 1, done: false }\niterator.return(4) // { value: 4, done: true } → yield 2 and yield 3 are skipped\niterator.next() // { value: undefined, done: true }\n</code></pre>\n<h2 id=\"conclusion\"><a href=\"#conclusion\"></a>Conclusion</h2>\n<p>Un habituel petit coup d'œil sur <a href=\"https://kangax.github.io/compat-table/es6/#test-generators\">la compatibilité</a> :</p>\n<ul>\n<li>Les navigateurs modernes (donc pas IE)</li>\n<li>IE Edge ≥ 13</li>\n<li>Niveau polyfill, c'est vers Babel ou Traceur qu'il faudra se tourner</li>\n</ul>\n<p>Les générateurs amènent tout un nouveau panel de fonctionnalités qui permettent\nd'inverser la responsabilité : c'est le code appelant qui prend le pouvoir sur\nla façon dont va s'exécuter la fonction appelée. Ils représentent le premier pas\nvers d'autres concepts qui bouleverseront probablement votre façon de coder dans\nquelques mois/années : fonctions asynchrones, observables… prennent leurs\nracines dans les générateurs. Les comprendre permettra de mieux appréhender de\nfutures fonctionnalités.</p>\n","rawBody":"\nUn gros morceau aujourd'hui : les itérateurs et les fonctions qui les génèrent,\nappelées \"générateurs\".\nES6/2015 apporte énormément de \"sucres syntaxiques\", même s'ils sont\nterriblement pratiques. Les valeurs par défaut, l'affectation par\ndéstructuration, les fonctions flêchées…\nTout ça n'apporte pas de réelle nouvelle fonctionnalité.\nC'est un peu différent pour les générateurs qui vont permettre de prendre le\ncontrôle sur l'éxécution d'une fonction depuis l'extérieur.\n\n## Fonction \"en pause\"\n\nUn nouveau mot-clé fait son apparition : ``function*``, une fonction marquée par\nl'astérisque n'est jamais exécutée directement, à la place, elle retourne un\n*itérateur*. Un générateur est donc capable de s'interrompre (d'ailleurs, il\nl'est par défaut).\nIl est également capable de reprendre là où il s'était arrêté :\nl'itérateur retourné est un objet exposant une méthode  ``next`` qui\nlorsqu'elle est appelée demande au générateur de reprendre là où il en était.\n\n```js\nfunction * idleFunction () {\n  console.log('World')\n}\n\nconst iterator = idleFunction()\n// L'exécution de la fonction est interrompue en attente d'être \"débloquée\"\nconsole.log('Hello')\niterator.next() // L'éxécution reprend et on affiche \"World\"\n```\n\nNotez qu'il ne s'agit pas de code **bloquant** : la fonction est mise en pause,\nson traitement sera repris plus tard, pendant ce temps l'*event-loop* continue\nsa petite vie.\n\n## Reprise du traitement et émission de valeur avec ``yield``\n\nLa méthode ``next()`` de l'itérateur retourne un objet possédant les propriétés\nsuivantes :\n\n* ``done`` vaut ``true`` quand le générateur a terminé son exécution\n* ``value`` est la valeur émise par le générateur dans cette portion de code\n\nComment émettre une valeur ? Le mot-clé ``yield`` a le double rôle de fournir\nune valeur et de remettre en pause l'exécution de la fonction. Le principe étant\nqu'on va émettre **plusieurs** valeurs, sinon on utiliserait simplement\n``return``.\n\n```js\nfunction * numbers () {\n  yield 1\n  yield 2\n}\n\nconst iterator = numbers()\niterator.next() // { value: 1, done: false }\niterator.next() // { value: 2, done: false }\niterator.next() // { value: undefined, done: true }\n```\n\nNote : si notre générateur ``return`` une valeur, elle sera affectée à la\npropriété ``value`` de la dernière itération.\n\n### _Use case_ : listes infinies\n\nUn premier _use case_ à ce stade est la possibilité de générer des listes de\nlongueur non définie à l'avance. On peut parcourir une suite dont on ne sait pas\nà l'avance *combien* d'éléments on veut, par exemple récupérer tous les éléments\nde la suite de Fibonacci inférieurs à 100 :\n\n```js\nfunction * fibo () {\n  let [a, b] = [1, 1]\n  while (true) { // Who can stop me?\n    [a, b] = [b, a + b]\n    yield a\n  }\n}\n\nconst iterator = fibo()\nfor (let n of iterator) {\n  if (n >= 100) {\n    break // *I* can stop you\n  }\n  console.log(n)\n}\n// 1 2 3 5 8 13 21 34 55 89\n```\n\nNote : l'opérateur ``for … of`` sera vu plus en détail dans un prochain article.\n\n## Passage de valeur au générateur\n\nOn a vu que ``yield`` permettait d'émettre une valeur depuis le générateur vers\nle code contrôleur. Mais le sens inverse est également possible : la méthode\n``next`` de l'itérateur accepte une valeur en paramètre, qui sera alors\nretournée par l'appel correspondant à ``yield``. Exemple :\n\n```js\nfunction * math () {\n  // Le premier appel à next() permet de \"démarrer\" le générateur\n  const x = yield // la valeur de la première itération sera undefined\n  // x = le paramètre du second appel à next()\n  const y = yield x + 1 // valeur de la seconde itération : x + 1\n  // y = paramètre du troisième appel à next()\n  yield y // valeur de la troisième itération : y\n  // le 4e appel (et +) à next() retournent { value: undefined, done: true }\n}\n\nconst iterator = math()\niterator.next(42) // { value: undefined, done: false }\n// Passer un paramètre au premier appel à next() n'est pas utile : cette valeur\n// n'est pas accessible dans le générateur car aucun \"yield\" correspondant\n\niterator.next(33) // { value: 34, done: false }, x = 33 dans le générateur\niterator.next(27) // { value: 27, done: false }, y = 27 dans le générateur\niterator.next() // { value: undefined, done: true }\n```\n\nÇa ne semble pas très utile vu comme ça, mais on peut passer à ``next()``\nn'importe quel type de donnée : une fonction, un objet, un autre itérateur… Les\npossibilités sont infinies. On va en explorer une rapidement avec les promesses.\n\n### _Use case_ : co-routines\n\nLe code du générateur lui-même ne peut être réellement asynchrone : les appels à\n``yield`` se suivent de manière synchrone. Le code contrôleur par contre, est\nlibre d'appeler ``next()`` à loisir, et peut donc le faire de manière asynchrone.\n\nOn a donc des fonctions dont on peut choisir quand elles sont interrompues, et\nquand elles peuvent reprendre leur traitement. Et si… notre générateur émettait\ndes promesses ? Histoire d'expliquer à son code contrôleur *quand* il est sûr de\nreprendre le traitement. Et si ce code contrôleur, voyant qu'il récupère une\npromesse, attendait que cette dernière soit résolue pour transmettre au\ngénérateur en retour la valeur résolue ? Dans ce cas le générateur pourrait\ndisposer de manière **synchrone** mais **non bloquante** de résultats de\ntraitements asynchrones :\n\n```js\nexecAsync(function * () {\n  console.log(\"Ajax request…\")\n  var rows = yield fetch(\"http://my.api/get\")\n  console.log(\"Work…\")\n  console.log(\"Save…\")\n  yield fetch(\"http://my.api/post\")\n  console.log(\"OK.\")\n}) // Ajax request… Work… Save… OK.\n```\n\nNe serait-ce pas merveilleux ? C'est le *_use case_* le plus intéressant pour\nnous au quotidien, et c'est assez simple en fait :\n\n```js\nfunction execAsync (promiseGenerator) {\n  const iter = promiseGenerator() // en pause…\n\n  function loop (iteration) {\n    if (iteration.done) { // Le générateur a return'é, fin du game\n      return iteration.value\n    }\n\n    // c'est un générateur de promesse, dont on attend la résolution ici\n    return iteration.value.then(result => {\n      // La promesse est résolue, on peut repasser sa valeur au générateur\n      const nextIteration = iter.next(result) // cette valeur est return'ée par\n      // le même \"yield\" qui a émis la promesse, ça tombe bien :)\n\n      // Puis on relance notre boucle, et on continue récursivement\n      return next(nextIteration)\n    })\n  }\n\n  const promiseIteration = iter.next() // exécution reprise jusqu'au prochain \"yield\"\n  // le générateur est remis en pause jusqu'au prochain appel à \"iter.next\"\n\n  // Première itération de la boucle\n  return loop(promiseIteration)\n}\n```\n\n## More! more! more!\n\n### Gestion d'erreur\n\nLes erreurs, tout comme les valeurs, peuvent être émises dans les deux\ndirections. Le générateur peut ``throw`` vers le code contrôleur (le code est\nsynchrone) :\n\n```js\nfunction * fail () {\n  yield 1\n  throw new Error('oops')\n  yield 2\n}\n\nconst iterator = fail()\niterator.next() // { value: 1, done: false }\ntry {\n  iterator.next() // throws\n} catch (e) {\n  e // Error('oops')\n}\n```\n\nMais le code contrôleur peut également émettre une erreur vers le générateur\navec la méthode ``throw`` de l'itérateur :\n\n```js\nfunction * fail () {\n  try {\n    yield 1\n  } catch (e) {\n    console.error(e)\n  }\n  yield 2\n}\n\nconst iterator = fail()\niterator.next() // { value: 1, done: false }\niterator.throw(new Error(\"nope\")) // affiche \"[Error: nope]\"\niterator.next() // { value: 2, done: false }\niterator.next() // { value: undefined, done: true }\n```\n\nNote : il faut bien se souvenir que le premier ``next`` sert à *débloquer*\nl'exécution du générateur, qui va alors jusqu'au premier ``yield``, évalue\nl'expression émise, la transmet en retour de ``next()``, et remet la fonction en\npause. C'est au second ``yield`` seulement que l'exécution reprend **à partir de\n``yield 1``**. C'est une partie que je trouve contre-intuitive et que j'ai eu du\nmal à assimiler.\n\n### Délégation\n\nL'opérateur ``yield*`` permet d'émettre les valeurs d'un autre itérateur, par\nexemple :\n\n```js\nfunction * oneToThree () {\n  yield 1\n  yield 2\n  yield 3\n}\n\nfunction * zeroToFour () {\n  yield 0\n  yield * oneToThree()\n  yield 4\n}\n```\n\nCela fonction bien sûr avec tous\n[les *itérables*](/fr/articles/js/es2015/iterators/) :\n``yield * [1, 2, 3]`` est valide par exemple.\n\n### Retour anticipé\n\nIl est possible de terminer le traitement d'un générateur depuis le code\ncontrôleur avec la méthode ``return`` de l'itérateur. Tout se passera comme si\nle générateur se terminait immédiatement avec la valeur de retour fournie.\n\n```js\nfunction * numbers () {\n  yield 1\n  yield 2\n  yield 3\n}\n\nconst iterator = numbers()\niterator.next() // { value: 1, done: false }\niterator.return(4) // { value: 4, done: true } → yield 2 and yield 3 are skipped\niterator.next() // { value: undefined, done: true }\n```\n\n## Conclusion\n\nUn habituel petit coup d'œil sur [la compatibilité](https://kangax.github.io/compat-table/es6/#test-generators) :\n\n* Les navigateurs modernes (donc pas IE)\n* IE Edge ≥ 13\n* Niveau polyfill, c'est vers Babel ou Traceur qu'il faudra se tourner\n\nLes générateurs amènent tout un nouveau panel de fonctionnalités qui permettent\nd'inverser la responsabilité : c'est le code appelant qui prend le pouvoir sur\nla façon dont va s'exécuter la fonction appelée. Ils représentent le premier pas\nvers d'autres concepts qui bouleverseront probablement votre façon de coder dans\nquelques mois/années : fonctions asynchrones, observables… prennent leurs\nracines dans les générateurs. Les comprendre permettra de mieux appréhender de\nfutures fonctionnalités.\n","raw":"---\ndate: \"2015-12-10\"\ntitle: \"ES6, ES2015 : itérateurs et générateurs\"\ntags:\n  - JavaScript\n  - ES6\n  - ES2015\nauthors:\n  - naholyr\n---\n\nUn gros morceau aujourd'hui : les itérateurs et les fonctions qui les génèrent,\nappelées \"générateurs\".\nES6/2015 apporte énormément de \"sucres syntaxiques\", même s'ils sont\nterriblement pratiques. Les valeurs par défaut, l'affectation par\ndéstructuration, les fonctions flêchées…\nTout ça n'apporte pas de réelle nouvelle fonctionnalité.\nC'est un peu différent pour les générateurs qui vont permettre de prendre le\ncontrôle sur l'éxécution d'une fonction depuis l'extérieur.\n\n## Fonction \"en pause\"\n\nUn nouveau mot-clé fait son apparition : ``function*``, une fonction marquée par\nl'astérisque n'est jamais exécutée directement, à la place, elle retourne un\n*itérateur*. Un générateur est donc capable de s'interrompre (d'ailleurs, il\nl'est par défaut).\nIl est également capable de reprendre là où il s'était arrêté :\nl'itérateur retourné est un objet exposant une méthode  ``next`` qui\nlorsqu'elle est appelée demande au générateur de reprendre là où il en était.\n\n```js\nfunction * idleFunction () {\n  console.log('World')\n}\n\nconst iterator = idleFunction()\n// L'exécution de la fonction est interrompue en attente d'être \"débloquée\"\nconsole.log('Hello')\niterator.next() // L'éxécution reprend et on affiche \"World\"\n```\n\nNotez qu'il ne s'agit pas de code **bloquant** : la fonction est mise en pause,\nson traitement sera repris plus tard, pendant ce temps l'*event-loop* continue\nsa petite vie.\n\n## Reprise du traitement et émission de valeur avec ``yield``\n\nLa méthode ``next()`` de l'itérateur retourne un objet possédant les propriétés\nsuivantes :\n\n* ``done`` vaut ``true`` quand le générateur a terminé son exécution\n* ``value`` est la valeur émise par le générateur dans cette portion de code\n\nComment émettre une valeur ? Le mot-clé ``yield`` a le double rôle de fournir\nune valeur et de remettre en pause l'exécution de la fonction. Le principe étant\nqu'on va émettre **plusieurs** valeurs, sinon on utiliserait simplement\n``return``.\n\n```js\nfunction * numbers () {\n  yield 1\n  yield 2\n}\n\nconst iterator = numbers()\niterator.next() // { value: 1, done: false }\niterator.next() // { value: 2, done: false }\niterator.next() // { value: undefined, done: true }\n```\n\nNote : si notre générateur ``return`` une valeur, elle sera affectée à la\npropriété ``value`` de la dernière itération.\n\n### _Use case_ : listes infinies\n\nUn premier _use case_ à ce stade est la possibilité de générer des listes de\nlongueur non définie à l'avance. On peut parcourir une suite dont on ne sait pas\nà l'avance *combien* d'éléments on veut, par exemple récupérer tous les éléments\nde la suite de Fibonacci inférieurs à 100 :\n\n```js\nfunction * fibo () {\n  let [a, b] = [1, 1]\n  while (true) { // Who can stop me?\n    [a, b] = [b, a + b]\n    yield a\n  }\n}\n\nconst iterator = fibo()\nfor (let n of iterator) {\n  if (n >= 100) {\n    break // *I* can stop you\n  }\n  console.log(n)\n}\n// 1 2 3 5 8 13 21 34 55 89\n```\n\nNote : l'opérateur ``for … of`` sera vu plus en détail dans un prochain article.\n\n## Passage de valeur au générateur\n\nOn a vu que ``yield`` permettait d'émettre une valeur depuis le générateur vers\nle code contrôleur. Mais le sens inverse est également possible : la méthode\n``next`` de l'itérateur accepte une valeur en paramètre, qui sera alors\nretournée par l'appel correspondant à ``yield``. Exemple :\n\n```js\nfunction * math () {\n  // Le premier appel à next() permet de \"démarrer\" le générateur\n  const x = yield // la valeur de la première itération sera undefined\n  // x = le paramètre du second appel à next()\n  const y = yield x + 1 // valeur de la seconde itération : x + 1\n  // y = paramètre du troisième appel à next()\n  yield y // valeur de la troisième itération : y\n  // le 4e appel (et +) à next() retournent { value: undefined, done: true }\n}\n\nconst iterator = math()\niterator.next(42) // { value: undefined, done: false }\n// Passer un paramètre au premier appel à next() n'est pas utile : cette valeur\n// n'est pas accessible dans le générateur car aucun \"yield\" correspondant\n\niterator.next(33) // { value: 34, done: false }, x = 33 dans le générateur\niterator.next(27) // { value: 27, done: false }, y = 27 dans le générateur\niterator.next() // { value: undefined, done: true }\n```\n\nÇa ne semble pas très utile vu comme ça, mais on peut passer à ``next()``\nn'importe quel type de donnée : une fonction, un objet, un autre itérateur… Les\npossibilités sont infinies. On va en explorer une rapidement avec les promesses.\n\n### _Use case_ : co-routines\n\nLe code du générateur lui-même ne peut être réellement asynchrone : les appels à\n``yield`` se suivent de manière synchrone. Le code contrôleur par contre, est\nlibre d'appeler ``next()`` à loisir, et peut donc le faire de manière asynchrone.\n\nOn a donc des fonctions dont on peut choisir quand elles sont interrompues, et\nquand elles peuvent reprendre leur traitement. Et si… notre générateur émettait\ndes promesses ? Histoire d'expliquer à son code contrôleur *quand* il est sûr de\nreprendre le traitement. Et si ce code contrôleur, voyant qu'il récupère une\npromesse, attendait que cette dernière soit résolue pour transmettre au\ngénérateur en retour la valeur résolue ? Dans ce cas le générateur pourrait\ndisposer de manière **synchrone** mais **non bloquante** de résultats de\ntraitements asynchrones :\n\n```js\nexecAsync(function * () {\n  console.log(\"Ajax request…\")\n  var rows = yield fetch(\"http://my.api/get\")\n  console.log(\"Work…\")\n  console.log(\"Save…\")\n  yield fetch(\"http://my.api/post\")\n  console.log(\"OK.\")\n}) // Ajax request… Work… Save… OK.\n```\n\nNe serait-ce pas merveilleux ? C'est le *_use case_* le plus intéressant pour\nnous au quotidien, et c'est assez simple en fait :\n\n```js\nfunction execAsync (promiseGenerator) {\n  const iter = promiseGenerator() // en pause…\n\n  function loop (iteration) {\n    if (iteration.done) { // Le générateur a return'é, fin du game\n      return iteration.value\n    }\n\n    // c'est un générateur de promesse, dont on attend la résolution ici\n    return iteration.value.then(result => {\n      // La promesse est résolue, on peut repasser sa valeur au générateur\n      const nextIteration = iter.next(result) // cette valeur est return'ée par\n      // le même \"yield\" qui a émis la promesse, ça tombe bien :)\n\n      // Puis on relance notre boucle, et on continue récursivement\n      return next(nextIteration)\n    })\n  }\n\n  const promiseIteration = iter.next() // exécution reprise jusqu'au prochain \"yield\"\n  // le générateur est remis en pause jusqu'au prochain appel à \"iter.next\"\n\n  // Première itération de la boucle\n  return loop(promiseIteration)\n}\n```\n\n## More! more! more!\n\n### Gestion d'erreur\n\nLes erreurs, tout comme les valeurs, peuvent être émises dans les deux\ndirections. Le générateur peut ``throw`` vers le code contrôleur (le code est\nsynchrone) :\n\n```js\nfunction * fail () {\n  yield 1\n  throw new Error('oops')\n  yield 2\n}\n\nconst iterator = fail()\niterator.next() // { value: 1, done: false }\ntry {\n  iterator.next() // throws\n} catch (e) {\n  e // Error('oops')\n}\n```\n\nMais le code contrôleur peut également émettre une erreur vers le générateur\navec la méthode ``throw`` de l'itérateur :\n\n```js\nfunction * fail () {\n  try {\n    yield 1\n  } catch (e) {\n    console.error(e)\n  }\n  yield 2\n}\n\nconst iterator = fail()\niterator.next() // { value: 1, done: false }\niterator.throw(new Error(\"nope\")) // affiche \"[Error: nope]\"\niterator.next() // { value: 2, done: false }\niterator.next() // { value: undefined, done: true }\n```\n\nNote : il faut bien se souvenir que le premier ``next`` sert à *débloquer*\nl'exécution du générateur, qui va alors jusqu'au premier ``yield``, évalue\nl'expression émise, la transmet en retour de ``next()``, et remet la fonction en\npause. C'est au second ``yield`` seulement que l'exécution reprend **à partir de\n``yield 1``**. C'est une partie que je trouve contre-intuitive et que j'ai eu du\nmal à assimiler.\n\n### Délégation\n\nL'opérateur ``yield*`` permet d'émettre les valeurs d'un autre itérateur, par\nexemple :\n\n```js\nfunction * oneToThree () {\n  yield 1\n  yield 2\n  yield 3\n}\n\nfunction * zeroToFour () {\n  yield 0\n  yield * oneToThree()\n  yield 4\n}\n```\n\nCela fonction bien sûr avec tous\n[les *itérables*](/fr/articles/js/es2015/iterators/) :\n``yield * [1, 2, 3]`` est valide par exemple.\n\n### Retour anticipé\n\nIl est possible de terminer le traitement d'un générateur depuis le code\ncontrôleur avec la méthode ``return`` de l'itérateur. Tout se passera comme si\nle générateur se terminait immédiatement avec la valeur de retour fournie.\n\n```js\nfunction * numbers () {\n  yield 1\n  yield 2\n  yield 3\n}\n\nconst iterator = numbers()\niterator.next() // { value: 1, done: false }\niterator.return(4) // { value: 4, done: true } → yield 2 and yield 3 are skipped\niterator.next() // { value: undefined, done: true }\n```\n\n## Conclusion\n\nUn habituel petit coup d'œil sur [la compatibilité](https://kangax.github.io/compat-table/es6/#test-generators) :\n\n* Les navigateurs modernes (donc pas IE)\n* IE Edge ≥ 13\n* Niveau polyfill, c'est vers Babel ou Traceur qu'il faudra se tourner\n\nLes générateurs amènent tout un nouveau panel de fonctionnalités qui permettent\nd'inverser la responsabilité : c'est le code appelant qui prend le pouvoir sur\nla façon dont va s'exécuter la fonction appelée. Ils représentent le premier pas\nvers d'autres concepts qui bouleverseront probablement votre façon de coder dans\nquelques mois/années : fonctions asynchrones, observables… prennent leurs\nracines dans les générateurs. Les comprendre permettra de mieux appréhender de\nfutures fonctionnalités.\n","__filename":"fr/articles/js/es2015/generators.md","__url":"/fr/articles/js/es2015/generators/","__resourceUrl":"/fr/articles/js/es2015/generators/index.html","__dataUrl":"/fr/articles/js/es2015/generators/index.html.c22a15559c4cf8d436e3a564dc1d835c.json"}