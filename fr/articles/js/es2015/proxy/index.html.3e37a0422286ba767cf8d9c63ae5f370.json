{"head":{"layout":"Post","comments":true,"date":"2015-12-18","title":"ES6, ES2015 : les Proxy","tags":["JavaScript","ES6","ES2015"],"authors":["DavidBruant"],"description":"Proxies Origin What the DOM? ES5 avait laissé un petit trou nommé \"host objects\" afin de donner un \"cadre légal\" aux trucs bizarres qui…"},"body":"<h2 id=\"proxies-origin\"><a href=\"#proxies-origin\"></a>Proxies Origin</h2>\n<h3 id=\"what-the-dom\"><a href=\"#what-the-dom\"></a>What the DOM?</h3>\n<p>ES5 avait laissé un petit trou nommé\n<em><a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-4.3.8\">\"host objects\"</a></em>\nafin de donner un \"cadre légal\" aux trucs bizarres qui peuvent arriver dans le\nDOM. Par exemple, certaines collections sont dites\n<a href=\"https://dom.spec.whatwg.org/#concept-collection-live\">\"live\"</a> et même si on ne\ntouche pas l'objet directement, on se rend compte que la collection a été\nmodifiée.</p>\n<pre><code class=\"language-js\">var childNodes = document.body.childNodes;\nconsole.log(childNodes.length); // 0\ndocument.body.appendChild(document.createElement('div'))\n// Personne n'a touché explicitement l'objet dans la variable divs, pourtant :\nconsole.log(childNodes.length); // 1, wat!\n</code></pre>\n<p>Ce genre de comportement n'est pas explicable par la sémantique d'ES5 (à moins\nd'accepter des gros problèmes de performances qui consisteraient à ce que le\nDOM garde une référence vers toutes les collections live et les mette à jour\nrégulièrement, ou des getter partout, etc.). La\n<a href=\"https://heycam.github.io/webidl/\">spec WebIDL</a> qui fait le lien entre les\nobjets décrits dans les spec W3C et la sémantique ECMAScript se contentait d'un\n\"c'est un <em>host object</em>, allé, salut les gars les filles !\" (en fait, c'était\npire que ça :\n<a href=\"http://www.w3.org/TR/DOM-Level-2-Core/ecma-script-binding.html\">la spec de\nl'époque</a>\nétait absurde tant elle manquait de détails, mais je vous fais la version de\nNoël).</p>\n<p>Mais ce genre d'explication n'est pas vraiment acceptable. Et si un navigateur\na un bug, comment je polyfille le comportement correct, hein ?</p>\n<p>Les proxies peuvent aider.</p>\n<h3 id=\"quest-il-arrivé-à-mon-objet-\"><a href=\"#quest-il-arriv%C3%A9-%C3%A0-mon-objet-\"></a>Qu'est-il arrivé à mon objet ?</h3>\n<p>Avant que la planète JS ne s'amourache des\n<a href=\"https://facebook.github.io/immutable-js/\">structures des données immutables</a>,\non créait des objets et des fois, on les passait à du code qui les modifiait et\non se demandait bien quand/comment l'objet en question en était arrivé dans cet\nétat. Depuis ES5, on peut logger dans des <em>getters</em> et <em>setters</em>, mais on ne\npeut pas savoir quand on s'est pris un <code>delete</code> ou un\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\">Object.freeze</a> ;\non peut constater le résultat, mais c'est dur de remonter à la source.</p>\n<p>Les proxies peuvent aider.</p>\n<h3 id=\"laisse-mon-objet-tranquille-\"><a href=\"#laisse-mon-objet-tranquille-\"></a>Laisse mon objet tranquille !</h3>\n<p>La sémantique des objets tel qu'on les utilise permet à différents scripts\nd'agir sur les mêmes objets, mais d'une manière qui ne permet pas forcément\ntoujours un contrôle fin. Par exemple, si je donne accès à la référence d'un\nobjet à quelqu'un, il possède cette référence pour toujours et dans la foulée\ntous les droits associés (donc modifier l'objet arbitrairement souvent) ; il\nn'est pas possible de <strong>révoquer</strong> l'accès dans le temps. Ce script a aussi\naccès à toutes les propriétés de l'objet, même si on voudrait n'en partager\nque certaines ; il n'est pas facile <strong>d'atténuer</strong> les droits à un objet (sans\ncréer de nouveaux objets et de se lancer dans des synchronisations coûteuses).</p>\n<h2 id=\"les-proxies-comment-ça-marche\"><a href=\"#les-proxies-comment-%C3%A7a-marche\"></a>Les proxies, comment ça marche</h2>\n<p>Un <strong>proxy</strong> est un nouvel objet (on ne peut pas transformer un objet en un\nproxy) qui \"emballe\" (<em>wrap</em>) un objet existant, la <strong>target</strong> et décrit le\ncomportement du proxy via un objet appelé le <strong>handler</strong> qui définit les\n<em>traps</em> du proxy.</p>\n<pre><code class=\"language-js\">const target = {a:1};\n\nconst handler = {\n    get(target, prop){\n        console.log(\"It's a (get) trap!\", prop, target[prop]);\n        return target[prop]+1;\n    }\n}\n\nconst proxy = new Proxy(target, handler);\nconsole.log(proxy.a);\n</code></pre>\n<p>console output:</p>\n<pre><code>It's a (get) trap! a 1 // inside the trap\n2 // new value modified by the trap\n</code></pre>\n<h3 id=\"liste-des-traps\"><a href=\"#liste-des-traps\"></a>Liste des traps</h3>\n<p>L'exemple ci-dessus montre la trap <code>get</code>. Voici la liste des traps\ndisponible :</p>\n<ul>\n<li>\n<p>getPrototypeOf</p>\n<ul>\n<li>pour <code>Object.getPrototypeOf</code></li>\n</ul>\n</li>\n<li>\n<p>setPrototypeOf</p>\n<ul>\n<li>pour <code>Object.setPrototypeOf</code></li>\n</ul>\n</li>\n<li>\n<p>isExtensible</p>\n<ul>\n<li>pour <code>Object.isExtensible</code></li>\n</ul>\n</li>\n<li>\n<p>preventExtensions</p>\n<ul>\n<li>pour <code>Object.preventExtensions</code></li>\n</ul>\n</li>\n<li>\n<p>getOwnPropertyDescriptor</p>\n<ul>\n<li>pour <code>Object.getOwnPropertyDescriptor</code></li>\n</ul>\n</li>\n<li>\n<p>defineProperty</p>\n<ul>\n<li>pour <code>Object.defineProperty</code></li>\n</ul>\n</li>\n<li>\n<p>has</p>\n<ul>\n<li>pour l'opérateur <code>in</code></li>\n</ul>\n</li>\n<li>\n<p>get</p>\n<ul>\n<li>pour <em>getter</em> une propriété</li>\n</ul>\n</li>\n<li>\n<p>set</p>\n<ul>\n<li>pour <em>setter</em> une propriété</li>\n</ul>\n</li>\n<li>\n<p>deleteProperty</p>\n<ul>\n<li>pour l'opérateur <code>delete</code></li>\n</ul>\n</li>\n<li>\n<p>enumerate</p>\n<ul>\n<li>pour les <code>for...in</code> et <code>Object.keys</code></li>\n</ul>\n</li>\n<li>\n<p>ownKeys</p>\n<ul>\n<li>pour <code>Object.getOwnPropertyNames</code></li>\n</ul>\n</li>\n<li>\n<p>apply</p>\n<ul>\n<li>pour quand on appelle le proxy comme une fonction.</li>\n</ul>\n</li>\n<li>\n<p>construct</p>\n<ul>\n<li>pour quand on appelle le proxy comme un constructeur (avec <code>new</code>).</li>\n</ul>\n</li>\n</ul>\n<p>Le lecteur attentif aura remarqué que cette liste (et les signatures des\nfonctions) correspondent à l'API</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect#Methods\">Reflect</a></p>\n<h2 id=\"solutions-aux-problèmes-précédents\"><a href=\"#solutions-aux-probl%C3%A8mes-pr%C3%A9c%C3%A9dents\"></a>Solutions aux problèmes précédents</h2>\n<h3 id=\"logger-les-opérations\"><a href=\"#logger-les-op%C3%A9rations\"></a>Logger les opérations</h3>\n<p>Vous voulez savoir quand on objet se prend un <code>delete</code> ? Rien de plus\nfacile !</p>\n<pre><code class=\"language-js\">const p = new Proxy({b: 2}, {\n    deleteProperty(target, prop){\n        console.log('Wow, someone just deleted', prop);\n        return Reflect.deleteProperty(target, prop);\n    },\n    freeze(target){\n        console.log('Wow, someone just froze the object');\n        return Reflect.freeze(target);\n    }\n})\n\ndelete p.b;\nObject.freeze(p);\n</code></pre>\n<h3 id=\"implémenter-des-nodelist-live\"><a href=\"#impl%C3%A9menter-des-nodelist-live\"></a>Implémenter des NodeList live</h3>\n<p>Ici, on prétend réimplémenter une collection DOM <em>live</em>.</p>\n<pre><code class=\"language-js\">function getChildNodesLiveCollection(parent){\n    return new Proxy({}, {\n        get: function(target, prop){\n            if(prop === \"length\"){\n                // l'astuce qui n'est pas de la triche , c'est qu'on va\n                // chercher la valeur au moment de l'appel\n                return parent.childNodes.length;\n            }\n            else\n                return target[prop];\n        }\n    })\n\n}\n\n\nvar liveChildNodes = getChildNodesLiveCollection(document.body);\nconsole.log(liveChildNodes.length); // 0\ndocument.body.appendChild(document.createElement('div'))\nconsole.log(liveChildNodes.length); // 1, magie magie !\n</code></pre>\n<h3 id=\"atténuation\"><a href=\"#att%C3%A9nuation\"></a>Atténuation</h3>\n<p>J'ai un objet avec plein de propriété et je veux en partager une version\natténuée à une bibliothèque en laquelle je n'ai qu'une confiance partielle.</p>\n<pre><code class=\"language-js\">// On va se faire MitM avec ce HTTP sans 'S' !\nimport dubiousLib from 'http://dubious-lib.com/main.js';\n\nconst myImportantObject = {\n    jfkKillerName: '...',\n    elvisGeoloc: {\n        long: '...',\n        lat: '...'\n    },\n    name: \"David Bruant\",\n    xmasPresentList: [\n        \"Raspberry Pi B\",\n        \"Nouveau téléphone (mais pas FirefoxOS, parce qu'ils arrêtent les\ntéls)\",\n        \"Une boîte de Tic Tac\"\n    ]\n}\n\nfunction makeWhitelistProxy(t, whitelist){\n    return new Proxy(t, {\n        get(target, prop){\n            if(!whitelist.has(prop))\n                throw new Error('Attempt to access forbidden property')\n\n            return Reflect.get(target, prop);\n        },\n        set(target, prop, value){\n            if(!whitelist.has(prop))\n                throw new Error('Attempt to access forbidden property')\n\n            return Reflect.set(target, prop, value);\n        },\n        getOwnPropertyDescriptor(target, prop){\n            if(!whitelist.has(prop))\n                throw new Error('Attempt to access forbidden property')\n\n            return Reflect.getOwnPropertyDescriptor(target, prop);\n        },\n        deleteProperty(target, prop){\n            if(!whitelist.has(prop))\n                throw new Error('Attempt to access forbidden property')\n\n            return Reflect.deleteProperty(target, prop);\n        },\n        defineProperty(target, prop, desc){\n            if(!whitelist.has(prop))\n                throw new Error('Attempt to access forbidden property')\n\n            return Reflect.defineProperty(target, prop, desc);\n        },\n        has(target, prop){\n            if(!whitelist.has(prop))\n                throw new Error('Attempt to access forbidden property')\n\n            return Reflect.has(target, prop);\n        }\n    })\n}\n\nconst attenatedObject = makeWhitelistProxy(\n    myImportantObject,\n    new Set([\"name\", \"xmasPresentList\"])\n);\n\nconsole.log(myImportantObject.name === attenatedObject.name);\nconsole.log(myImportantObject.jfkKillerName); // \"...\"\nconsole.log(attenatedObject.jfkKillerName);\n// error thrown! 'Error: Attempt to access forbidden property'\n\ndubiousLib(attenatedObject);\n</code></pre>\n<p>On peut imaginer d'autres formes d'atténuation, comme ne donner accès qu'en\nlecture à l'objet alors que l'on garde soi-même un accès en écriture (ce qui\nest impossible avec <code>Object.freeze</code>).</p>\n<h3 id=\"révocation\"><a href=\"#r%C3%A9vocation\"></a>Révocation</h3>\n<p>On peut révoquer l'accès à un objet en implémentant le <em>pattern</em> \"caretaker\"</p>\n<pre><code class=\"language-js\">function makeCaretaker(t){\n    return {\n        revoke(){\n            t = undefined;\n        },\n        proxy: new Proxy(t, {\n            get(target, prop){\n                return Reflect.get(target, prop);\n            },\n            set(target, prop, value){\n                return Reflect.get(target, prop, value);\n            }\n            // flemme d'écrire et vous faire lire les autres traps,\n            // mais faut toutes les faire ;-)\n        })\n    }\n}\n\nconst o = {};\nconst {revoke, proxy} = makeCaretaker(o);\n\nproxy.a = 12;\n\nconsole.log(o.a, proxy.a); // 12 12\n\nproxy.b = 37;\ndelete proxy.a;\n\nrevoke();\n\nproxy.b; // BOOM! TypeError: target is not a non-null object\n</code></pre>\n<h4 id=\"via-un-meta-proxy\"><a href=\"#via-un-meta-proxy\"></a>...via un meta-proxy</h4>\n<p>La petite astuce rigolote avec les proxy, vu que l'API est dite <em>stratifiée</em>,\nc'est que vu que le handler est un objet, on pourrait en faire un proxy pour\nimplémenter la révocation plus simplement.</p>\n<pre><code class=\"language-js\">function makeCaretaker(target){\n    const metaHandler = {\n        get(handler, trapName){\n            if(!target)\n                throw new Error('Revoked object!')\n            else\n                // Le miroir entre les traps et l'API Reflect vient de là ;-)\n                return Reflect[trapName];\n        }\n    }\n\n    const handler = new Proxy({}, metaHandler);\n\n    return {\n        revoke(){\n            target = undefined;\n        },\n        proxy: new Proxy(target, handler)\n    };\n}\n\nconst o = {};\nconst {revoke, proxy} = makeCaretaker(o);\n\nproxy.a = 12;\n\nconsole.log(o.a, proxy.a); // 12 12\n\nproxy.b = 37;\ndelete proxy.a;\n\nrevoke();\n\nproxy.b; // BOOM! TypeError: target is not a non-null object\n</code></pre>\n<p>Il fait mal au crâne au début celui-là, mais après relecture, on se sent bien.</p>\n<p>Pour des raisons par très intéressantes, les proxy révocables sont fournis\ndirectement via</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/revocable\">Proxy.revocable</a>,\ndonc, pas besoin de se fatiguer à le coder avec toutes les traps ou avec un\nmeta handler.</p>\n<h2 id=\"conclusion\"><a href=\"#conclusion\"></a>Conclusion</h2>\n<p>Les proxies sont un outil bas niveau et puissant. Avec de grands pouvoirs\nviennent de grandes responsabilités, alors comprenez bien cet outil avant de\nvouloir l'utiliser partout.</p>\n","rawBody":"\n## Proxies Origin\n\n### What the DOM?\n\nES5 avait laissé un petit trou nommé\n*[\"host objects\"](http://www.ecma-international.org/ecma-262/5.1/#sec-4.3.8)*\nafin de donner un \"cadre légal\" aux trucs bizarres qui peuvent arriver dans le\nDOM. Par exemple, certaines collections sont dites\n[\"live\"](https://dom.spec.whatwg.org/#concept-collection-live) et même si on ne\ntouche pas l'objet directement, on se rend compte que la collection a été\nmodifiée.\n\n```js\nvar childNodes = document.body.childNodes;\nconsole.log(childNodes.length); // 0\ndocument.body.appendChild(document.createElement('div'))\n// Personne n'a touché explicitement l'objet dans la variable divs, pourtant :\nconsole.log(childNodes.length); // 1, wat!\n```\n\nCe genre de comportement n'est pas explicable par la sémantique d'ES5 (à moins\nd'accepter des gros problèmes de performances qui consisteraient à ce que le\nDOM garde une référence vers toutes les collections live et les mette à jour\nrégulièrement, ou des getter partout, etc.). La\n[spec WebIDL](https://heycam.github.io/webidl/) qui fait le lien entre les\nobjets décrits dans les spec W3C et la sémantique ECMAScript se contentait d'un\n\"c'est un *host object*, allé, salut les gars les filles !\" (en fait, c'était\npire que ça&nbsp;:\n[la spec de\nl'époque](http://www.w3.org/TR/DOM-Level-2-Core/ecma-script-binding.html)\nétait absurde tant elle manquait de détails, mais je vous fais la version de\nNoël).\n\nMais ce genre d'explication n'est pas vraiment acceptable. Et si un navigateur\na un bug, comment je polyfille le comportement correct, hein ?\n\nLes proxies peuvent aider.\n\n\n### Qu'est-il arrivé à mon objet ?\n\nAvant que la planète JS ne s'amourache des\n[structures des données immutables](https://facebook.github.io/immutable-js/),\non créait des objets et des fois, on les passait à du code qui les modifiait et\non se demandait bien quand/comment l'objet en question en était arrivé dans cet\nétat. Depuis ES5, on peut logger dans des *getters* et *setters*, mais on ne\npeut pas savoir quand on s'est pris un `delete` ou un\n[Object.freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)&nbsp;;\non peut constater le résultat, mais c'est dur de remonter à la source.\n\nLes proxies peuvent aider.\n\n\n### Laisse mon objet tranquille !\n\nLa sémantique des objets tel qu'on les utilise permet à différents scripts\nd'agir sur les mêmes objets, mais d'une manière qui ne permet pas forcément\ntoujours un contrôle fin. Par exemple, si je donne accès à la référence d'un\nobjet à quelqu'un, il possède cette référence pour toujours et dans la foulée\ntous les droits associés (donc modifier l'objet arbitrairement souvent) ; il\nn'est pas possible de **révoquer** l'accès dans le temps. Ce script a aussi\naccès à toutes les propriétés de l'objet, même si on voudrait n'en partager\nque certaines ; il n'est pas facile **d'atténuer** les droits à un objet (sans\ncréer de nouveaux objets et de se lancer dans des synchronisations coûteuses).\n\n\n## Les proxies, comment ça marche\n\nUn **proxy** est un nouvel objet (on ne peut pas transformer un objet en un\nproxy) qui \"emballe\" (*wrap*) un objet existant, la **target** et décrit le\ncomportement du proxy via un objet appelé le **handler** qui définit les\n*traps* du proxy.\n\n```js\nconst target = {a:1};\n\nconst handler = {\n    get(target, prop){\n        console.log(\"It's a (get) trap!\", prop, target[prop]);\n        return target[prop]+1;\n    }\n}\n\nconst proxy = new Proxy(target, handler);\nconsole.log(proxy.a);\n```\n\nconsole output:\n\n```\nIt's a (get) trap! a 1 // inside the trap\n2 // new value modified by the trap\n```\n\n\n### Liste des traps\n\nL'exemple ci-dessus montre la trap `get`. Voici la liste des traps\ndisponible&nbsp;:\n\n* getPrototypeOf\n    * pour `Object.getPrototypeOf`\n* setPrototypeOf\n    * pour `Object.setPrototypeOf`\n* isExtensible\n    * pour `Object.isExtensible`\n* preventExtensions\n    * pour `Object.preventExtensions`\n* getOwnPropertyDescriptor\n    * pour `Object.getOwnPropertyDescriptor`\n* defineProperty\n    * pour `Object.defineProperty`\n* has\n    * pour l'opérateur `in`\n* get\n    * pour *getter* une propriété\n* set\n    * pour *setter* une propriété\n* deleteProperty\n    * pour l'opérateur `delete`\n* enumerate\n    * pour les `for...in` et `Object.keys`\n* ownKeys\n    * pour `Object.getOwnPropertyNames`\n* apply\n    * pour quand on appelle le proxy comme une fonction.\n* construct\n    * pour quand on appelle le proxy comme un constructeur (avec `new`).\n\nLe lecteur attentif aura remarqué que cette liste (et les signatures des\nfonctions) correspondent à l'API\n\n[Reflect](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect#Methods)\n\n\n## Solutions aux problèmes précédents\n\n### Logger les opérations\n\nVous voulez savoir quand on objet se prend un `delete`&nbsp;? Rien de plus\nfacile&nbsp;!\n\n\n````js\nconst p = new Proxy({b: 2}, {\n    deleteProperty(target, prop){\n        console.log('Wow, someone just deleted', prop);\n        return Reflect.deleteProperty(target, prop);\n    },\n    freeze(target){\n        console.log('Wow, someone just froze the object');\n        return Reflect.freeze(target);\n    }\n})\n\ndelete p.b;\nObject.freeze(p);\n````\n\n\n### Implémenter des NodeList live\n\nIci, on prétend réimplémenter une collection DOM *live*.\n\n````js\nfunction getChildNodesLiveCollection(parent){\n    return new Proxy({}, {\n        get: function(target, prop){\n            if(prop === \"length\"){\n                // l'astuce qui n'est pas de la triche , c'est qu'on va\n                // chercher la valeur au moment de l'appel\n                return parent.childNodes.length;\n            }\n            else\n                return target[prop];\n        }\n    })\n\n}\n\n\nvar liveChildNodes = getChildNodesLiveCollection(document.body);\nconsole.log(liveChildNodes.length); // 0\ndocument.body.appendChild(document.createElement('div'))\nconsole.log(liveChildNodes.length); // 1, magie magie !\n````\n\n\n### Atténuation\n\nJ'ai un objet avec plein de propriété et je veux en partager une version\natténuée à une bibliothèque en laquelle je n'ai qu'une confiance partielle.\n\n````js\n// On va se faire MitM avec ce HTTP sans 'S' !\nimport dubiousLib from 'http://dubious-lib.com/main.js';\n\nconst myImportantObject = {\n    jfkKillerName: '...',\n    elvisGeoloc: {\n        long: '...',\n        lat: '...'\n    },\n    name: \"David Bruant\",\n    xmasPresentList: [\n        \"Raspberry Pi B\",\n        \"Nouveau téléphone (mais pas FirefoxOS, parce qu'ils arrêtent les\ntéls)\",\n        \"Une boîte de Tic Tac\"\n    ]\n}\n\nfunction makeWhitelistProxy(t, whitelist){\n    return new Proxy(t, {\n        get(target, prop){\n            if(!whitelist.has(prop))\n                throw new Error('Attempt to access forbidden property')\n\n            return Reflect.get(target, prop);\n        },\n        set(target, prop, value){\n            if(!whitelist.has(prop))\n                throw new Error('Attempt to access forbidden property')\n\n            return Reflect.set(target, prop, value);\n        },\n        getOwnPropertyDescriptor(target, prop){\n            if(!whitelist.has(prop))\n                throw new Error('Attempt to access forbidden property')\n\n            return Reflect.getOwnPropertyDescriptor(target, prop);\n        },\n        deleteProperty(target, prop){\n            if(!whitelist.has(prop))\n                throw new Error('Attempt to access forbidden property')\n\n            return Reflect.deleteProperty(target, prop);\n        },\n        defineProperty(target, prop, desc){\n            if(!whitelist.has(prop))\n                throw new Error('Attempt to access forbidden property')\n\n            return Reflect.defineProperty(target, prop, desc);\n        },\n        has(target, prop){\n            if(!whitelist.has(prop))\n                throw new Error('Attempt to access forbidden property')\n\n            return Reflect.has(target, prop);\n        }\n    })\n}\n\nconst attenatedObject = makeWhitelistProxy(\n    myImportantObject,\n    new Set([\"name\", \"xmasPresentList\"])\n);\n\nconsole.log(myImportantObject.name === attenatedObject.name);\nconsole.log(myImportantObject.jfkKillerName); // \"...\"\nconsole.log(attenatedObject.jfkKillerName);\n// error thrown! 'Error: Attempt to access forbidden property'\n\ndubiousLib(attenatedObject);\n\n````\n\nOn peut imaginer d'autres formes d'atténuation, comme ne donner accès qu'en\nlecture à l'objet alors que l'on garde soi-même un accès en écriture (ce qui\nest impossible avec `Object.freeze`).\n\n\n### Révocation\n\nOn peut révoquer l'accès à un objet en implémentant le *pattern* \"caretaker\"\n\n````js\nfunction makeCaretaker(t){\n    return {\n        revoke(){\n            t = undefined;\n        },\n        proxy: new Proxy(t, {\n            get(target, prop){\n                return Reflect.get(target, prop);\n            },\n            set(target, prop, value){\n                return Reflect.get(target, prop, value);\n            }\n            // flemme d'écrire et vous faire lire les autres traps,\n            // mais faut toutes les faire ;-)\n        })\n    }\n}\n\nconst o = {};\nconst {revoke, proxy} = makeCaretaker(o);\n\nproxy.a = 12;\n\nconsole.log(o.a, proxy.a); // 12 12\n\nproxy.b = 37;\ndelete proxy.a;\n\nrevoke();\n\nproxy.b; // BOOM! TypeError: target is not a non-null object\n````\n\n\n#### ...via un meta-proxy\n\nLa petite astuce rigolote avec les proxy, vu que l'API est dite *stratifiée*,\nc'est que vu que le handler est un objet, on pourrait en faire un proxy pour\nimplémenter la révocation plus simplement.\n\n````js\nfunction makeCaretaker(target){\n    const metaHandler = {\n        get(handler, trapName){\n            if(!target)\n                throw new Error('Revoked object!')\n            else\n                // Le miroir entre les traps et l'API Reflect vient de là ;-)\n                return Reflect[trapName];\n        }\n    }\n\n    const handler = new Proxy({}, metaHandler);\n\n    return {\n        revoke(){\n            target = undefined;\n        },\n        proxy: new Proxy(target, handler)\n    };\n}\n\nconst o = {};\nconst {revoke, proxy} = makeCaretaker(o);\n\nproxy.a = 12;\n\nconsole.log(o.a, proxy.a); // 12 12\n\nproxy.b = 37;\ndelete proxy.a;\n\nrevoke();\n\nproxy.b; // BOOM! TypeError: target is not a non-null object\n\n````\n\nIl fait mal au crâne au début celui-là, mais après relecture, on se sent bien.\n\nPour des raisons par très intéressantes, les proxy révocables sont fournis\ndirectement via\n\n[Proxy.revocable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/revocable),\ndonc, pas besoin de se fatiguer à le coder avec toutes les traps ou avec un\nmeta handler.\n\n\n## Conclusion\n\nLes proxies sont un outil bas niveau et puissant. Avec de grands pouvoirs\nviennent de grandes responsabilités, alors comprenez bien cet outil avant de\nvouloir l'utiliser partout.\n","raw":"---\ndate: \"2015-12-18\"\ntitle: \"ES6, ES2015 : les Proxy\"\ntags:\n  - JavaScript\n  - ES6\n  - ES2015\nauthors:\n  - DavidBruant\n---\n\n## Proxies Origin\n\n### What the DOM?\n\nES5 avait laissé un petit trou nommé\n*[\"host objects\"](http://www.ecma-international.org/ecma-262/5.1/#sec-4.3.8)*\nafin de donner un \"cadre légal\" aux trucs bizarres qui peuvent arriver dans le\nDOM. Par exemple, certaines collections sont dites\n[\"live\"](https://dom.spec.whatwg.org/#concept-collection-live) et même si on ne\ntouche pas l'objet directement, on se rend compte que la collection a été\nmodifiée.\n\n```js\nvar childNodes = document.body.childNodes;\nconsole.log(childNodes.length); // 0\ndocument.body.appendChild(document.createElement('div'))\n// Personne n'a touché explicitement l'objet dans la variable divs, pourtant :\nconsole.log(childNodes.length); // 1, wat!\n```\n\nCe genre de comportement n'est pas explicable par la sémantique d'ES5 (à moins\nd'accepter des gros problèmes de performances qui consisteraient à ce que le\nDOM garde une référence vers toutes les collections live et les mette à jour\nrégulièrement, ou des getter partout, etc.). La\n[spec WebIDL](https://heycam.github.io/webidl/) qui fait le lien entre les\nobjets décrits dans les spec W3C et la sémantique ECMAScript se contentait d'un\n\"c'est un *host object*, allé, salut les gars les filles !\" (en fait, c'était\npire que ça&nbsp;:\n[la spec de\nl'époque](http://www.w3.org/TR/DOM-Level-2-Core/ecma-script-binding.html)\nétait absurde tant elle manquait de détails, mais je vous fais la version de\nNoël).\n\nMais ce genre d'explication n'est pas vraiment acceptable. Et si un navigateur\na un bug, comment je polyfille le comportement correct, hein ?\n\nLes proxies peuvent aider.\n\n\n### Qu'est-il arrivé à mon objet ?\n\nAvant que la planète JS ne s'amourache des\n[structures des données immutables](https://facebook.github.io/immutable-js/),\non créait des objets et des fois, on les passait à du code qui les modifiait et\non se demandait bien quand/comment l'objet en question en était arrivé dans cet\nétat. Depuis ES5, on peut logger dans des *getters* et *setters*, mais on ne\npeut pas savoir quand on s'est pris un `delete` ou un\n[Object.freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)&nbsp;;\non peut constater le résultat, mais c'est dur de remonter à la source.\n\nLes proxies peuvent aider.\n\n\n### Laisse mon objet tranquille !\n\nLa sémantique des objets tel qu'on les utilise permet à différents scripts\nd'agir sur les mêmes objets, mais d'une manière qui ne permet pas forcément\ntoujours un contrôle fin. Par exemple, si je donne accès à la référence d'un\nobjet à quelqu'un, il possède cette référence pour toujours et dans la foulée\ntous les droits associés (donc modifier l'objet arbitrairement souvent) ; il\nn'est pas possible de **révoquer** l'accès dans le temps. Ce script a aussi\naccès à toutes les propriétés de l'objet, même si on voudrait n'en partager\nque certaines ; il n'est pas facile **d'atténuer** les droits à un objet (sans\ncréer de nouveaux objets et de se lancer dans des synchronisations coûteuses).\n\n\n## Les proxies, comment ça marche\n\nUn **proxy** est un nouvel objet (on ne peut pas transformer un objet en un\nproxy) qui \"emballe\" (*wrap*) un objet existant, la **target** et décrit le\ncomportement du proxy via un objet appelé le **handler** qui définit les\n*traps* du proxy.\n\n```js\nconst target = {a:1};\n\nconst handler = {\n    get(target, prop){\n        console.log(\"It's a (get) trap!\", prop, target[prop]);\n        return target[prop]+1;\n    }\n}\n\nconst proxy = new Proxy(target, handler);\nconsole.log(proxy.a);\n```\n\nconsole output:\n\n```\nIt's a (get) trap! a 1 // inside the trap\n2 // new value modified by the trap\n```\n\n\n### Liste des traps\n\nL'exemple ci-dessus montre la trap `get`. Voici la liste des traps\ndisponible&nbsp;:\n\n* getPrototypeOf\n    * pour `Object.getPrototypeOf`\n* setPrototypeOf\n    * pour `Object.setPrototypeOf`\n* isExtensible\n    * pour `Object.isExtensible`\n* preventExtensions\n    * pour `Object.preventExtensions`\n* getOwnPropertyDescriptor\n    * pour `Object.getOwnPropertyDescriptor`\n* defineProperty\n    * pour `Object.defineProperty`\n* has\n    * pour l'opérateur `in`\n* get\n    * pour *getter* une propriété\n* set\n    * pour *setter* une propriété\n* deleteProperty\n    * pour l'opérateur `delete`\n* enumerate\n    * pour les `for...in` et `Object.keys`\n* ownKeys\n    * pour `Object.getOwnPropertyNames`\n* apply\n    * pour quand on appelle le proxy comme une fonction.\n* construct\n    * pour quand on appelle le proxy comme un constructeur (avec `new`).\n\nLe lecteur attentif aura remarqué que cette liste (et les signatures des\nfonctions) correspondent à l'API\n\n[Reflect](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect#Methods)\n\n\n## Solutions aux problèmes précédents\n\n### Logger les opérations\n\nVous voulez savoir quand on objet se prend un `delete`&nbsp;? Rien de plus\nfacile&nbsp;!\n\n\n````js\nconst p = new Proxy({b: 2}, {\n    deleteProperty(target, prop){\n        console.log('Wow, someone just deleted', prop);\n        return Reflect.deleteProperty(target, prop);\n    },\n    freeze(target){\n        console.log('Wow, someone just froze the object');\n        return Reflect.freeze(target);\n    }\n})\n\ndelete p.b;\nObject.freeze(p);\n````\n\n\n### Implémenter des NodeList live\n\nIci, on prétend réimplémenter une collection DOM *live*.\n\n````js\nfunction getChildNodesLiveCollection(parent){\n    return new Proxy({}, {\n        get: function(target, prop){\n            if(prop === \"length\"){\n                // l'astuce qui n'est pas de la triche , c'est qu'on va\n                // chercher la valeur au moment de l'appel\n                return parent.childNodes.length;\n            }\n            else\n                return target[prop];\n        }\n    })\n\n}\n\n\nvar liveChildNodes = getChildNodesLiveCollection(document.body);\nconsole.log(liveChildNodes.length); // 0\ndocument.body.appendChild(document.createElement('div'))\nconsole.log(liveChildNodes.length); // 1, magie magie !\n````\n\n\n### Atténuation\n\nJ'ai un objet avec plein de propriété et je veux en partager une version\natténuée à une bibliothèque en laquelle je n'ai qu'une confiance partielle.\n\n````js\n// On va se faire MitM avec ce HTTP sans 'S' !\nimport dubiousLib from 'http://dubious-lib.com/main.js';\n\nconst myImportantObject = {\n    jfkKillerName: '...',\n    elvisGeoloc: {\n        long: '...',\n        lat: '...'\n    },\n    name: \"David Bruant\",\n    xmasPresentList: [\n        \"Raspberry Pi B\",\n        \"Nouveau téléphone (mais pas FirefoxOS, parce qu'ils arrêtent les\ntéls)\",\n        \"Une boîte de Tic Tac\"\n    ]\n}\n\nfunction makeWhitelistProxy(t, whitelist){\n    return new Proxy(t, {\n        get(target, prop){\n            if(!whitelist.has(prop))\n                throw new Error('Attempt to access forbidden property')\n\n            return Reflect.get(target, prop);\n        },\n        set(target, prop, value){\n            if(!whitelist.has(prop))\n                throw new Error('Attempt to access forbidden property')\n\n            return Reflect.set(target, prop, value);\n        },\n        getOwnPropertyDescriptor(target, prop){\n            if(!whitelist.has(prop))\n                throw new Error('Attempt to access forbidden property')\n\n            return Reflect.getOwnPropertyDescriptor(target, prop);\n        },\n        deleteProperty(target, prop){\n            if(!whitelist.has(prop))\n                throw new Error('Attempt to access forbidden property')\n\n            return Reflect.deleteProperty(target, prop);\n        },\n        defineProperty(target, prop, desc){\n            if(!whitelist.has(prop))\n                throw new Error('Attempt to access forbidden property')\n\n            return Reflect.defineProperty(target, prop, desc);\n        },\n        has(target, prop){\n            if(!whitelist.has(prop))\n                throw new Error('Attempt to access forbidden property')\n\n            return Reflect.has(target, prop);\n        }\n    })\n}\n\nconst attenatedObject = makeWhitelistProxy(\n    myImportantObject,\n    new Set([\"name\", \"xmasPresentList\"])\n);\n\nconsole.log(myImportantObject.name === attenatedObject.name);\nconsole.log(myImportantObject.jfkKillerName); // \"...\"\nconsole.log(attenatedObject.jfkKillerName);\n// error thrown! 'Error: Attempt to access forbidden property'\n\ndubiousLib(attenatedObject);\n\n````\n\nOn peut imaginer d'autres formes d'atténuation, comme ne donner accès qu'en\nlecture à l'objet alors que l'on garde soi-même un accès en écriture (ce qui\nest impossible avec `Object.freeze`).\n\n\n### Révocation\n\nOn peut révoquer l'accès à un objet en implémentant le *pattern* \"caretaker\"\n\n````js\nfunction makeCaretaker(t){\n    return {\n        revoke(){\n            t = undefined;\n        },\n        proxy: new Proxy(t, {\n            get(target, prop){\n                return Reflect.get(target, prop);\n            },\n            set(target, prop, value){\n                return Reflect.get(target, prop, value);\n            }\n            // flemme d'écrire et vous faire lire les autres traps,\n            // mais faut toutes les faire ;-)\n        })\n    }\n}\n\nconst o = {};\nconst {revoke, proxy} = makeCaretaker(o);\n\nproxy.a = 12;\n\nconsole.log(o.a, proxy.a); // 12 12\n\nproxy.b = 37;\ndelete proxy.a;\n\nrevoke();\n\nproxy.b; // BOOM! TypeError: target is not a non-null object\n````\n\n\n#### ...via un meta-proxy\n\nLa petite astuce rigolote avec les proxy, vu que l'API est dite *stratifiée*,\nc'est que vu que le handler est un objet, on pourrait en faire un proxy pour\nimplémenter la révocation plus simplement.\n\n````js\nfunction makeCaretaker(target){\n    const metaHandler = {\n        get(handler, trapName){\n            if(!target)\n                throw new Error('Revoked object!')\n            else\n                // Le miroir entre les traps et l'API Reflect vient de là ;-)\n                return Reflect[trapName];\n        }\n    }\n\n    const handler = new Proxy({}, metaHandler);\n\n    return {\n        revoke(){\n            target = undefined;\n        },\n        proxy: new Proxy(target, handler)\n    };\n}\n\nconst o = {};\nconst {revoke, proxy} = makeCaretaker(o);\n\nproxy.a = 12;\n\nconsole.log(o.a, proxy.a); // 12 12\n\nproxy.b = 37;\ndelete proxy.a;\n\nrevoke();\n\nproxy.b; // BOOM! TypeError: target is not a non-null object\n\n````\n\nIl fait mal au crâne au début celui-là, mais après relecture, on se sent bien.\n\nPour des raisons par très intéressantes, les proxy révocables sont fournis\ndirectement via\n\n[Proxy.revocable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/revocable),\ndonc, pas besoin de se fatiguer à le coder avec toutes les traps ou avec un\nmeta handler.\n\n\n## Conclusion\n\nLes proxies sont un outil bas niveau et puissant. Avec de grands pouvoirs\nviennent de grandes responsabilités, alors comprenez bien cet outil avant de\nvouloir l'utiliser partout.\n","__filename":"fr/articles/js/es2015/proxy.md","__url":"/fr/articles/js/es2015/proxy/","__resourceUrl":"/fr/articles/js/es2015/proxy/index.html","__dataUrl":"/fr/articles/js/es2015/proxy/index.html.3e37a0422286ba767cf8d9c63ae5f370.json"}