{"head":{"layout":"Post","comments":true,"date":"2015-12-05","title":"ES6, ES2015 : les classes","tags":["javascript","ES6","ES2015"],"authors":["magsout"],"description":"Les classes introduites par ES2015 ne sont clairement que du sucre syntaxique. Elles n'apportent rien de plus en terme de fonctionnalité…"},"body":"<p>Les classes introduites par <code>ES2015</code> ne sont clairement que du sucre syntaxique.\nElles n'apportent rien de plus en terme de fonctionnalité. Toutefois, l'objectif\nde cette évolution est de rendre le code plus lisible et plus facilement\naccessible.</p>\n<h2 id=\"déclaration-de-classes\"><a href=\"#d%C3%A9claration-de-classes\"></a>Déclaration de classes</h2>\n<p>Oubliez les fonctions anonymes et les prototypes, la sémantique a pris le\nrelais, comme vous pouvez le constater dans l'exemple de déclaration de la\nclasse <code>User</code> :</p>\n<pre><code class=\"language-js\">class User {\n  // méthode constructor\n  constructor(firstname, lastname) {\n    this.firstname = firstname;\n    this.lastname = lastname;\n  }\n\n  sayName() {\n    return `${this.firstname} ${this.lastname}`\n  }\n}\n\n// instanciation\nconst user = new User(\"John\", \"Doe\")\n\n// appel de la méthode sayName()\nconsole.log(user.sayName()) // John Doe\n</code></pre>\n<p>Pour rappel, voici une <a href=\"https://gist.github.com/magsout/a876b2fa8240a987e523\">façon possible\nd'écrire</a> cette classe en\n<code>es5</code> :</p>\n<pre><code class=\"language-js\">function User(firstname, lastname) {\n  if(!(this instanceof User)) {\n    throw new TypeError(\"Class constructors cannot be invoked without 'new'\")\n  }\n  this.firstname = firstname\n  this.lastname = lastname\n}\n\nUser.prototype.sayName = function() {\n  return this.firstname + \" \" + this.lastname\n}\n\n// instanciation\nvar user = new User(\"John\", \"Doe\")\n\n// appel de la méthode sayName()\nconsole.log(user.sayName()) // John Doe\n</code></pre>\n<h2 id=\"expressions-de-classes\"><a href=\"#expressions-de-classes\"></a>Expressions de classes</h2>\n<p>Toutes les méthodes s'écrivent comme de simples fonctions à l'intérieur de la\nclasse. Bien entendu, les getter/setter sont toujours de la partie mais bien\nplus simples à utiliser :</p>\n<pre><code class=\"language-JS\">class User {\n  // constructor\n  constructor(firstname, lastname, type) {\n    this.firstname = firstname\n    this.lastname = lastname\n    this.type = type\n  }\n\n  // méthode\n  sayName() {\n   return `${this.firstname}  ${this.lastname}`\n  }\n\n  // getter\n  get role() {\n    return this.type\n  }\n\n  // setter\n  set role(value) {\n    return this.type = value\n  }\n}\n\n// le `new` est obligatoire pour appeler une classe\nconst user = new User(\"John\", \"Doe\", \"Contributor\")\n\nconsole.log(user.sayName()) // John Doe\nconsole.log(user.role) // Contributor\nuser.role = \"owner\"\nconsole.log(user.role) // Owner\n</code></pre>\n<h2 id=\"lhéritage\"><a href=\"#lh%C3%A9ritage\"></a>L'héritage</h2>\n<p>Pour qu'une sous-classe hérite d'une autre classe on utilisera le mot\nclé <code>extends</code>.</p>\n<p>En utilisant notre exemple précédent :</p>\n<pre><code class=\"language-js\">class Contributor extends User {\n  constructor(firstname, lastname, numberCommit) {\n\n    // le mot clé super est utilisé comme super contructeur. Il permet d'appeler\n    // et d'avoir accès aux méthodes du parent\n    super(firstname, lastname)\n    this.numberCommit = numberCommit\n  }\n\n  sayNameWithCommit() {\n    // on peut appeler une méthode de la classe parente avec `super.method`\n    return super.sayName() + \" \" + this.sayNumberCommit()\n  }\n\n  sayNumberCommit() {\n    return this.numberCommit\n  }\n}\n\n// instanciation\nconst contributor = new Contributor('Jane', 'Smith', 10)\n\n// appel de la méthode sayName()\nconsole.log(contributor.sayName())\nconsole.log(contributor.sayNumberCommit())\n</code></pre>\n<p><strong>Rappel : <a href=\"https://www.youtube.com/watch?v=wfMtDGfHWpA\">préférez la composition à l'héritage</a>.</strong></p>\n<h2 id=\"thats-it\"><a href=\"#thats-it\"></a>That's it</h2>\n<p>Concrètement, tout ce qui est possible de faire avec cette nouvelle notation\nl'était bien entendu\n<a href=\"https://gist.github.com/bloodyowl/7edc9c973d2236ed17e1\">avant</a>.</p>\n<p>Au final, on gagne en clarté, en lisibilité et donc en maintenabilité.</p>\n<p>À l'heure actuelle, il est nécessaire de passer par un transpileur comme\n<a href=\"https://babeljs.io/\">babel</a> pour utiliser les classes.</p>\n<p>Une dernière petite chose, le\n<a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Strict_mode\">mode strict</a>\nest automatiquement activé dans le corps des classes et leurs déclarations.\nIl n'est donc pas nécessaire de le rajouter manuellement.</p>\n<pre><code class=\"language-js\">/* Mode strict initial */\nclass MyClass {\n  someMethod() {\n    /* Ici le mode strict est implicitement activé */\n  }\n}\n/* Mode strict inchangé */\n</code></pre>\n","rawBody":"\nLes classes introduites par `ES2015` ne sont clairement que du sucre syntaxique.\nElles n'apportent rien de plus en terme de fonctionnalité. Toutefois, l'objectif\nde cette évolution est de rendre le code plus lisible et plus facilement\naccessible.\n\n## Déclaration de classes\n\nOubliez les fonctions anonymes et les prototypes, la sémantique a pris le\nrelais, comme vous pouvez le constater dans l'exemple de déclaration de la\nclasse `User` :\n\n```js\nclass User {\n  // méthode constructor\n  constructor(firstname, lastname) {\n    this.firstname = firstname;\n    this.lastname = lastname;\n  }\n\n  sayName() {\n    return `${this.firstname} ${this.lastname}`\n  }\n}\n\n// instanciation\nconst user = new User(\"John\", \"Doe\")\n\n// appel de la méthode sayName()\nconsole.log(user.sayName()) // John Doe\n```\n\nPour rappel, voici une [façon possible\nd'écrire](https://gist.github.com/magsout/a876b2fa8240a987e523) cette classe en\n`es5` :\n\n```js\nfunction User(firstname, lastname) {\n  if(!(this instanceof User)) {\n    throw new TypeError(\"Class constructors cannot be invoked without 'new'\")\n  }\n  this.firstname = firstname\n  this.lastname = lastname\n}\n\nUser.prototype.sayName = function() {\n  return this.firstname + \" \" + this.lastname\n}\n\n// instanciation\nvar user = new User(\"John\", \"Doe\")\n\n// appel de la méthode sayName()\nconsole.log(user.sayName()) // John Doe\n```\n\n## Expressions de classes\n\nToutes les méthodes s'écrivent comme de simples fonctions à l'intérieur de la\nclasse. Bien entendu, les getter/setter sont toujours de la partie mais bien\nplus simples à utiliser :\n\n```JS\nclass User {\n  // constructor\n  constructor(firstname, lastname, type) {\n    this.firstname = firstname\n    this.lastname = lastname\n    this.type = type\n  }\n\n  // méthode\n  sayName() {\n   return `${this.firstname}  ${this.lastname}`\n  }\n\n  // getter\n  get role() {\n    return this.type\n  }\n\n  // setter\n  set role(value) {\n    return this.type = value\n  }\n}\n\n// le `new` est obligatoire pour appeler une classe\nconst user = new User(\"John\", \"Doe\", \"Contributor\")\n\nconsole.log(user.sayName()) // John Doe\nconsole.log(user.role) // Contributor\nuser.role = \"owner\"\nconsole.log(user.role) // Owner\n```\n\n## L'héritage\n\nPour qu'une sous-classe hérite d'une autre classe on utilisera le mot\nclé `extends`.\n\nEn utilisant notre exemple précédent :\n\n```js\nclass Contributor extends User {\n  constructor(firstname, lastname, numberCommit) {\n\n    // le mot clé super est utilisé comme super contructeur. Il permet d'appeler\n    // et d'avoir accès aux méthodes du parent\n    super(firstname, lastname)\n    this.numberCommit = numberCommit\n  }\n\n  sayNameWithCommit() {\n    // on peut appeler une méthode de la classe parente avec `super.method`\n    return super.sayName() + \" \" + this.sayNumberCommit()\n  }\n\n  sayNumberCommit() {\n    return this.numberCommit\n  }\n}\n\n// instanciation\nconst contributor = new Contributor('Jane', 'Smith', 10)\n\n// appel de la méthode sayName()\nconsole.log(contributor.sayName())\nconsole.log(contributor.sayNumberCommit())\n\n```\n\n**Rappel : [préférez la composition à l'héritage](https://www.youtube.com/watch?v=wfMtDGfHWpA).**\n\n## That's it\n\nConcrètement, tout ce qui est possible de faire avec cette nouvelle notation\nl'était bien entendu\n[avant](https://gist.github.com/bloodyowl/7edc9c973d2236ed17e1).\n\nAu final, on gagne en clarté, en lisibilité et donc en maintenabilité.\n\nÀ l'heure actuelle, il est nécessaire de passer par un transpileur comme\n[babel](https://babeljs.io/) pour utiliser les classes.\n\nUne dernière petite chose, le \n[mode strict](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Strict_mode) \nest automatiquement activé dans le corps des classes et leurs déclarations.\nIl n'est donc pas nécessaire de le rajouter manuellement.\n\n```js\n/* Mode strict initial */\nclass MyClass {\n  someMethod() {\n    /* Ici le mode strict est implicitement activé */\n  }\n}\n/* Mode strict inchangé */\n```\n","raw":"---\ndate: \"2015-12-05\"\ntitle: \"ES6, ES2015 : les classes\"\ntags:\n  - javascript\n  - ES6\n  - ES2015\nauthors:\n  - magsout\n---\n\nLes classes introduites par `ES2015` ne sont clairement que du sucre syntaxique.\nElles n'apportent rien de plus en terme de fonctionnalité. Toutefois, l'objectif\nde cette évolution est de rendre le code plus lisible et plus facilement\naccessible.\n\n## Déclaration de classes\n\nOubliez les fonctions anonymes et les prototypes, la sémantique a pris le\nrelais, comme vous pouvez le constater dans l'exemple de déclaration de la\nclasse `User` :\n\n```js\nclass User {\n  // méthode constructor\n  constructor(firstname, lastname) {\n    this.firstname = firstname;\n    this.lastname = lastname;\n  }\n\n  sayName() {\n    return `${this.firstname} ${this.lastname}`\n  }\n}\n\n// instanciation\nconst user = new User(\"John\", \"Doe\")\n\n// appel de la méthode sayName()\nconsole.log(user.sayName()) // John Doe\n```\n\nPour rappel, voici une [façon possible\nd'écrire](https://gist.github.com/magsout/a876b2fa8240a987e523) cette classe en\n`es5` :\n\n```js\nfunction User(firstname, lastname) {\n  if(!(this instanceof User)) {\n    throw new TypeError(\"Class constructors cannot be invoked without 'new'\")\n  }\n  this.firstname = firstname\n  this.lastname = lastname\n}\n\nUser.prototype.sayName = function() {\n  return this.firstname + \" \" + this.lastname\n}\n\n// instanciation\nvar user = new User(\"John\", \"Doe\")\n\n// appel de la méthode sayName()\nconsole.log(user.sayName()) // John Doe\n```\n\n## Expressions de classes\n\nToutes les méthodes s'écrivent comme de simples fonctions à l'intérieur de la\nclasse. Bien entendu, les getter/setter sont toujours de la partie mais bien\nplus simples à utiliser :\n\n```JS\nclass User {\n  // constructor\n  constructor(firstname, lastname, type) {\n    this.firstname = firstname\n    this.lastname = lastname\n    this.type = type\n  }\n\n  // méthode\n  sayName() {\n   return `${this.firstname}  ${this.lastname}`\n  }\n\n  // getter\n  get role() {\n    return this.type\n  }\n\n  // setter\n  set role(value) {\n    return this.type = value\n  }\n}\n\n// le `new` est obligatoire pour appeler une classe\nconst user = new User(\"John\", \"Doe\", \"Contributor\")\n\nconsole.log(user.sayName()) // John Doe\nconsole.log(user.role) // Contributor\nuser.role = \"owner\"\nconsole.log(user.role) // Owner\n```\n\n## L'héritage\n\nPour qu'une sous-classe hérite d'une autre classe on utilisera le mot\nclé `extends`.\n\nEn utilisant notre exemple précédent :\n\n```js\nclass Contributor extends User {\n  constructor(firstname, lastname, numberCommit) {\n\n    // le mot clé super est utilisé comme super contructeur. Il permet d'appeler\n    // et d'avoir accès aux méthodes du parent\n    super(firstname, lastname)\n    this.numberCommit = numberCommit\n  }\n\n  sayNameWithCommit() {\n    // on peut appeler une méthode de la classe parente avec `super.method`\n    return super.sayName() + \" \" + this.sayNumberCommit()\n  }\n\n  sayNumberCommit() {\n    return this.numberCommit\n  }\n}\n\n// instanciation\nconst contributor = new Contributor('Jane', 'Smith', 10)\n\n// appel de la méthode sayName()\nconsole.log(contributor.sayName())\nconsole.log(contributor.sayNumberCommit())\n\n```\n\n**Rappel : [préférez la composition à l'héritage](https://www.youtube.com/watch?v=wfMtDGfHWpA).**\n\n## That's it\n\nConcrètement, tout ce qui est possible de faire avec cette nouvelle notation\nl'était bien entendu\n[avant](https://gist.github.com/bloodyowl/7edc9c973d2236ed17e1).\n\nAu final, on gagne en clarté, en lisibilité et donc en maintenabilité.\n\nÀ l'heure actuelle, il est nécessaire de passer par un transpileur comme\n[babel](https://babeljs.io/) pour utiliser les classes.\n\nUne dernière petite chose, le \n[mode strict](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Strict_mode) \nest automatiquement activé dans le corps des classes et leurs déclarations.\nIl n'est donc pas nécessaire de le rajouter manuellement.\n\n```js\n/* Mode strict initial */\nclass MyClass {\n  someMethod() {\n    /* Ici le mode strict est implicitement activé */\n  }\n}\n/* Mode strict inchangé */\n```\n","__filename":"fr/articles/js/es2015/classes.md","__url":"/fr/articles/js/es2015/classes/","__resourceUrl":"/fr/articles/js/es2015/classes/index.html","__dataUrl":"/fr/articles/js/es2015/classes/index.html.df733b4ee4a87f2d55b9f3c2225e75a3.json"}