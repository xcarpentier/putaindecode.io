{"head":{"layout":"Post","comments":true,"date":"2015-12-02","title":"ES6, ES2015 : le destructuring","tags":["javascript","ES6","ES2015"],"authors":["bloodyowl"],"description":"Le principe Le destructuring consiste à assigner des variables provenant d'un objet ou tableau en reposant sur leur structure. Les…"},"body":"<h2 id=\"le-principe\"><a href=\"#le-principe\"></a>Le principe</h2>\n<p>Le destructuring consiste à assigner des variables provenant d'un objet ou\ntableau en reposant sur leur structure.</p>\n<pre><code class=\"language-js\">// Partons d'un objet `myObject`\nvar myObject = {\n  foo: 1,\n  bar: 2,\n}\n\n// Avec ES5, vous deviez par exemple faire\nvar foo = myObject.foo\nvar bar = myObject.bar\n\nfoo // 1\nbar // 2\n\n// Avec ES6, vous pouvez désormais l'écrire sous la forme\nconst { foo, bar } = myObject\nfoo // 1\nbar // 2\n\n// On peut bien entendu destructurer la valeur retournée par une\n// fonction, pour peu qu'il s'agisse d'un objet ou d'un tableau\nconst getMyObject = function() {\n  return {\n    foo: 1,\n    bar: 2,\n  }\n}\nconst { foo, bar } = getMyObject()\nfoo // 1\nbar // 2\n</code></pre>\n<h2 id=\"les-différentes-syntaxes\"><a href=\"#les-diff%C3%A9rentes-syntaxes\"></a>Les différentes syntaxes</h2>\n<h3 id=\"tableau\"><a href=\"#tableau\"></a>Tableau</h3>\n<pre><code class=\"language-js\">// Pour un tableau, on utilise une forme proche de la déclaration litérale de\n// tableau, vous remarquerez que pour ignorer un item, il suffit de ne rien\n// placer entre les virgules\nconst [ first, second, , fourth ] = [1, 2, 3, 4]\nfirst // 1\nsecond // 2\nfourth // 4\n</code></pre>\n<h3 id=\"utiliser-un-nom-différent-de-la-clé\"><a href=\"#utiliser-un-nom-diff%C3%A9rent-de-la-cl%C3%A9\"></a>Utiliser un nom différent de la clé</h3>\n<p>Pour un objet, par défaut, le nom de la variable correspond au nom de la clé.\nSi, par exemple, vous avez déjà une variable portant le nom de la clé dans le\nscope, vous pouvez choisir de nommer différemment votre variable.</p>\n<pre><code class=\"language-js\">var myObject = {\n  foo: 1,\n  bar: 2\n}\nconst { foo: renamedFoo } = myObject\nrenamedFoo // 1\n</code></pre>\n<p>Cette syntaxe est, il faut tout de même le noter, peu lisible.</p>\n<h3 id=\"arguments-de-fonctions\"><a href=\"#arguments-de-fonctions\"></a>Arguments de fonctions</h3>\n<pre><code class=\"language-js\">// On peut directement utiliser le destructuring dans une déclaration de\n// fonction\nfunction myFunction({ title, text }) {\n    return title + \": \" + text\n}\n\nmyFunction({ title: \"foo\", text: \"bar\" }) // \"foo: bar\"\n</code></pre>\n<h3 id=\"nested-destructuring\"><a href=\"#nested-destructuring\"></a>Nested destructuring</h3>\n<p>On peut aussi imbriquer les assignements.</p>\n<pre><code class=\"language-js\">var myObject = {\n  foo: {\n    bar: 1,\n  },\n}\nconst { foo: { bar } } = myObject\nbar // 1\n</code></pre>\n<p>Attention cependant, si le destructuring au premier niveau ne fera que retourner\n<code>undefined</code> si la valeur n'existe pas, vous aurez bel et bien une erreur avec le\nnesting, puisqu'il essaiera d'aller chercher une propriété d'<code>undefined</code>.\nPour pallier ces soucis, rendez-vous pour l'article sur les\n<a href=\"/fr/articles/js/es2015/defaults/\">defaults</a>.</p>\n","rawBody":"\n## Le principe\n\nLe destructuring consiste à assigner des variables provenant d'un objet ou\ntableau en reposant sur leur structure.\n\n```js\n// Partons d'un objet `myObject`\nvar myObject = {\n  foo: 1,\n  bar: 2,\n}\n\n// Avec ES5, vous deviez par exemple faire\nvar foo = myObject.foo\nvar bar = myObject.bar\n\nfoo // 1\nbar // 2\n\n// Avec ES6, vous pouvez désormais l'écrire sous la forme\nconst { foo, bar } = myObject\nfoo // 1\nbar // 2\n\n// On peut bien entendu destructurer la valeur retournée par une\n// fonction, pour peu qu'il s'agisse d'un objet ou d'un tableau\nconst getMyObject = function() {\n  return {\n    foo: 1,\n    bar: 2,\n  }\n}\nconst { foo, bar } = getMyObject()\nfoo // 1\nbar // 2\n```\n\n\n## Les différentes syntaxes\n\n### Tableau\n\n```js\n// Pour un tableau, on utilise une forme proche de la déclaration litérale de\n// tableau, vous remarquerez que pour ignorer un item, il suffit de ne rien\n// placer entre les virgules\nconst [ first, second, , fourth ] = [1, 2, 3, 4]\nfirst // 1\nsecond // 2\nfourth // 4\n```\n\n### Utiliser un nom différent de la clé\n\nPour un objet, par défaut, le nom de la variable correspond au nom de la clé.\nSi, par exemple, vous avez déjà une variable portant le nom de la clé dans le\nscope, vous pouvez choisir de nommer différemment votre variable.\n\n```js\nvar myObject = {\n  foo: 1,\n  bar: 2\n}\nconst { foo: renamedFoo } = myObject\nrenamedFoo // 1\n```\n\nCette syntaxe est, il faut tout de même le noter, peu lisible.\n\n### Arguments de fonctions\n\n```js\n// On peut directement utiliser le destructuring dans une déclaration de\n// fonction\nfunction myFunction({ title, text }) {\n\treturn title + \": \" + text\n}\n\nmyFunction({ title: \"foo\", text: \"bar\" }) // \"foo: bar\"\n```\n\n### Nested destructuring\n\nOn peut aussi imbriquer les assignements.\n\n```js\nvar myObject = {\n  foo: {\n    bar: 1,\n  },\n}\nconst { foo: { bar } } = myObject\nbar // 1\n```\n\nAttention cependant, si le destructuring au premier niveau ne fera que retourner\n`undefined` si la valeur n'existe pas, vous aurez bel et bien une erreur avec le\nnesting, puisqu'il essaiera d'aller chercher une propriété d'`undefined`.\nPour pallier ces soucis, rendez-vous pour l'article sur les\n[defaults](/fr/articles/js/es2015/defaults/).\n","raw":"---\ndate: \"2015-12-02\"\ntitle: \"ES6, ES2015 : le destructuring\"\ntags:\n  - javascript\n  - ES6\n  - ES2015\nauthors:\n  - bloodyowl\n---\n\n## Le principe\n\nLe destructuring consiste à assigner des variables provenant d'un objet ou\ntableau en reposant sur leur structure.\n\n```js\n// Partons d'un objet `myObject`\nvar myObject = {\n  foo: 1,\n  bar: 2,\n}\n\n// Avec ES5, vous deviez par exemple faire\nvar foo = myObject.foo\nvar bar = myObject.bar\n\nfoo // 1\nbar // 2\n\n// Avec ES6, vous pouvez désormais l'écrire sous la forme\nconst { foo, bar } = myObject\nfoo // 1\nbar // 2\n\n// On peut bien entendu destructurer la valeur retournée par une\n// fonction, pour peu qu'il s'agisse d'un objet ou d'un tableau\nconst getMyObject = function() {\n  return {\n    foo: 1,\n    bar: 2,\n  }\n}\nconst { foo, bar } = getMyObject()\nfoo // 1\nbar // 2\n```\n\n\n## Les différentes syntaxes\n\n### Tableau\n\n```js\n// Pour un tableau, on utilise une forme proche de la déclaration litérale de\n// tableau, vous remarquerez que pour ignorer un item, il suffit de ne rien\n// placer entre les virgules\nconst [ first, second, , fourth ] = [1, 2, 3, 4]\nfirst // 1\nsecond // 2\nfourth // 4\n```\n\n### Utiliser un nom différent de la clé\n\nPour un objet, par défaut, le nom de la variable correspond au nom de la clé.\nSi, par exemple, vous avez déjà une variable portant le nom de la clé dans le\nscope, vous pouvez choisir de nommer différemment votre variable.\n\n```js\nvar myObject = {\n  foo: 1,\n  bar: 2\n}\nconst { foo: renamedFoo } = myObject\nrenamedFoo // 1\n```\n\nCette syntaxe est, il faut tout de même le noter, peu lisible.\n\n### Arguments de fonctions\n\n```js\n// On peut directement utiliser le destructuring dans une déclaration de\n// fonction\nfunction myFunction({ title, text }) {\n\treturn title + \": \" + text\n}\n\nmyFunction({ title: \"foo\", text: \"bar\" }) // \"foo: bar\"\n```\n\n### Nested destructuring\n\nOn peut aussi imbriquer les assignements.\n\n```js\nvar myObject = {\n  foo: {\n    bar: 1,\n  },\n}\nconst { foo: { bar } } = myObject\nbar // 1\n```\n\nAttention cependant, si le destructuring au premier niveau ne fera que retourner\n`undefined` si la valeur n'existe pas, vous aurez bel et bien une erreur avec le\nnesting, puisqu'il essaiera d'aller chercher une propriété d'`undefined`.\nPour pallier ces soucis, rendez-vous pour l'article sur les\n[defaults](/fr/articles/js/es2015/defaults/).\n","__filename":"fr/articles/js/es2015/destructuring.md","__url":"/fr/articles/js/es2015/destructuring/","__resourceUrl":"/fr/articles/js/es2015/destructuring/index.html","__dataUrl":"/fr/articles/js/es2015/destructuring/index.html.c47c5b03aa43a53d7d76d57cd5b5dce3.json"}