{"head":{"layout":"Post","comments":true,"date":"2016-06-07","title":"Introduction à Flow, pour du code qui tourne du premier coup","tags":["javascript","flow","type"],"authors":["bloodyowl"],"description":"Cette hypothétique ligne de code ne fonctionne pas tout le temps. La raison c'est que element.firstChild est un Node et que tous les Node…"},"body":"<pre><code class=\"language-javascript\">document.body.firstChild.getBoundingClientRect()\n</code></pre>\n<p>Cette hypothétique ligne de code ne fonctionne pas tout le temps.</p>\n<p>La raison c'est que <code>element.firstChild</code> est un <code>Node</code> et que tous les <code>Node</code> ne possèdent pas la méthode <code>getBoundingClientRect</code>, que l'on trouve systématiquement sur les <code>Element</code>, une classe héritant de <code>Node</code>.</p>\n<p>Ce type d'erreur est assez commun, et malheureusement JavaScript n'en fout pas une pour nous prévenir que <em>attention là ça peut merder</em>. Le langage préfère nous prévenir au <em>runtime</em>, quand c'est déjà trop tard, parce que le bug s'est produit.</p>\n<p>Et c'est parce que JavaScript est un langage … à typage <strong>faible</strong> et <strong>dynamique</strong>.</p>\n<p>Faible, parce que si l'on effectue une opération entre deux valeurs ayant des types incompatibles, JavaScript va essayer de convertir les types de la manière qui lui semble la moins déconnante.</p>\n<p>Exemple <em>feat. la conscience de JavaScript™</em></p>\n<pre><code class=\"language-javascript\">\"1\" + 1\n// bon alors, vu que la string peut être à peu près n'importe quoi,\n// y'a un bon risque pour qu'une conversion en chiffre donne NaN,\n// donc on va plutôt convertir le chiffre en string et faire une\n// concaténation\n\"11\"\n</code></pre>\n<pre><code class=\"language-javascript\">\"1\" * 1\n// putain mais qui a écrit cette merde encore ?\n// bon ben là si c'est une multiplication j'ai pas le choix,\n// on va convertir la string en nombre\n1\n</code></pre>\n<p>Dynamique, en opposition à statique, parce que les tests de type sont faits au runtime.</p>\n<pre><code class=\"language-javascript\">const toLowerCase = (value) => {\n  return value.toLowerCase()\n}\n\ntoLowerCase(3)\n// bon alors, (3).toLowerCase c'est undefined\n// undefined c'est pas une fonction, ERREUR\n</code></pre>\n<h2 id=\"comment-on-a-fait-jusque-là-\"><a href=\"#comment-on-a-fait-jusque-l%C3%A0-\"></a>Comment on a fait jusque là ?</h2>\n<h3 id=\"de-la-documentation\"><a href=\"#de-la-documentation\"></a>De la documentation</h3>\n<pre><code class=\"language-javascript\">/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nconst multiply = (a, b) => {\n  return a * b\n}\n</code></pre>\n<p>Ah bah c'est bien, maintenant toute l'équipe sait quels types sont attendus. Ça n'empêche pas les erreurs au runtime mais au moins on est au courant.</p>\n<h3 id=\"aller-à-fond-dans-le-typage-dynamique\"><a href=\"#aller-%C3%A0-fond-dans-le-typage-dynamique\"></a>Aller à fond dans le typage dynamique</h3>\n<pre><code class=\"language-javascript\">const multiply = (a, b) => {\n  if(typeof a !== \"number\") {\n    throw new TypeError()\n  }\n  if(typeof b !== \"number\") {\n    throw new TypeError()\n  }\n  return a * b\n}\n</code></pre>\n<p>On peut vérifier les types au runtime pour détecter les bugs possibles de manière plus drastique en dev, on se retrouvera toujours avec un souci en production, qui fera péter le comportement attendu.</p>\n<h3 id=\"faire-comme-si-cétait-pas-grave\"><a href=\"#faire-comme-si-c%C3%A9tait-pas-grave\"></a>Faire comme si c'était pas grave</h3>\n<pre><code class=\"language-javascript\">const multiply = (a, b) => {\n  if(typeof a !== \"number\") {\n    a = 0\n  }\n  if(typeof b !== \"number\") {\n    b = 0\n  }\n  return a * b\n}\n</code></pre>\n<p>On peut faire du \"defensive programming\". Au lieu de laisser le bug arriver, on le tolère. Dans 99% des cas, le résultat ne sera absolument pas celui que l'on attend, et on ne prévient même pas de quand ça foire.</p>\n<h2 id=\"comment-ça-se-passe-ailleurs-\"><a href=\"#comment-%C3%A7a-se-passe-ailleurs-\"></a>Comment ça se passe ailleurs ?</h2>\n<p>D'autres langages utilisent un typage statique, ce qui veut dire que le programme ne compilera pas si les types peuvent être incorrects.</p>\n<pre><code class=\"language-ocaml\">let value = \"1\";;\n\nvalue + 1;;\n</code></pre>\n<p>OCaml, quand vous essayez de faire tourner ce code va vous sortir un gros</p>\n<pre><code>File \"test.ml\", line 3, characters 0-5:\nError: This expression has type string but an expression was expected of type\n         int\n</code></pre>\n<h2 id=\"et-comment-peut-on-avoir-ça-en-js-\"><a href=\"#et-comment-peut-on-avoir-%C3%A7a-en-js-\"></a>Et comment peut-on avoir ça en JS ?</h2>\n<p>C'est là que <a href=\"http://flowtype.org\">Flow</a> intervient. C'est un outil d'analyse statique de JS. Il détecte les incompatibilités de types au sein du code.</p>\n<pre><code class=\"language-javascript\">/* @flow */\nconst multiply = (a, b) => {\n  return a * b\n}\n\nmultiply(1, \"1\")\n</code></pre>\n<pre><code>6: multiply(1, \"1\")\n   ^^^^^^^^^^^^^^^^ function call\n3:   return a * b\n                ^ string. This type is incompatible with\n3:   return a * b\n            ^^^^^ number\n</code></pre>\n<p>Dans le cas précédent, Flow analyse le code et comprend qu'une opération entre <code>string</code> et <code>number</code> comporte une incompatibilité.</p>\n<p>Du coup, on peut avoir du code qui tourne du premier coup parce qu'il a éliminé toutes nos petites erreurs bêtes. En prime, ça permet d'arrêter de faire des tests unitaires bateau sur les types.</p>\n<p>Flow ajoute par ailleurs une syntaxe pour définir les types attendus dans une situation donnée. On utilise <code>:</code> suivi du type attendu.</p>\n<pre><code class=\"language-javascript\">/* @flow */\n// les types built-ins sont compris naturellement par flow\nconst foo: string = \"foo\"\nconst bar: number = 3\n// on peut typer les valeurs contenues dans un array\nconst baz: Array&#x3C;string> = [\"foo\", \"bar\"]\n// on peut typer des structures\nconst object: { foo: string, bar: number } = { foo, bar }\n// définir des valeurs litérales autorisées\nconst value: \"enabled\" | \"disabled\" = \"enabled\"\n// des unions de types\nconst stringOrNumber: string | number = \"foo\"\n\nfunction sum(array: Array&#x3C;number>): number {\n  return array.reduce((acc, item) => acc + item, 0)\n}\n\nclass Person {\n  name: string;\n  constructor(name: string) { this.name = name }\n}\n// utiliser la relation prototypale pour typer une valeur\nconst person: Person = new Person(\"foo\")\n</code></pre>\n<p>Flow permet également de créer des alias de types, ce qui est essentiel pour les partager au sein d'une codebase. Une syntaxe pour importer les types de fichier existe également. Ces imports sont supprimés du build final.</p>\n<pre><code class=\"language-javascript\">/* @flow */\nimport type { MediaType } from \"./MediaType\"\n\nexport type UserType = {\n  username: string,\n  firstName?: string,\n  lastName?: string,\n  email: string,\n  avatar: MediaType,\n}\n</code></pre>\n<p>Lorsque l'on écrit du code qui se fout du type, on peut utiliser les <em>generics</em>, qui est une sorte de placeholder de type.</p>\n<pre><code class=\"language-javascript\">/* @flow */\n// `T` est ici un type qui sera défini au call-site.\nfunction findLast&#x3C;T> (\n  array: Array&#x3C;T>,\n  func: (item: T, index: number, array: Array&#x3C;T>) => any\n): null | T {\n  let index = array.length\n  while(--index >= 0) {\n    const item = array[index]\n    if(func(item, index, array)) {\n      return item\n    }\n  }\n  return null\n}\n\n// Flow sait que dans ce cas `T` est un nombre\nconst lastEvenNumber: ?number = findLast(\n  [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ],\n  (item) => item % 2 === 0\n)\n</code></pre>\n<p>Flow permet également de typer par structure partielle attendue.</p>\n<pre><code class=\"language-javascript\">/* @flow */\n// l'inteface `named` permet de s'assurer que la valeur testée contient\n// une méthode `getName` retournant une `string`\ninterface named {\n  getName(): string,\n}\n\nclass Person {\n  name: string;\n  constructor(name: string) {\n    this.name = name\n  }\n  getName() {\n    return this.name\n  }\n}\n\nconst person: named = new Person(\"Luke Skywalker\")\n</code></pre>\n<p>React est supporté directement, et Flow peut remplacer les <code>propTypes</code>.</p>\n<pre><code class=\"language-javascript\">/* @flow */\nimport React, { Component } from \"react\"\nimport type { Element as ReactElement } from \"react\"\nimport type { UserType } from \"../types/UserType\"\n\n// &#x3C;DefaultProps, Props, State>\nclass User extends Component&#x3C;void, Props, void> {\n  render(): ReactElement {\n    return (\n      &#x3C;div>\n        {user.username}\n      &#x3C;/div>\n    )\n  }\n}\n\ntype Props = {\n  user: UserType,\n}\n</code></pre>\n<h2 id=\"mais-cest-pas-du-js-valide\"><a href=\"#mais-cest-pas-du-js-valide\"></a>Mais c'est pas du JS valide</h2>\n<p>Pas de panique, pour ça il existe des plugins babel:</p>\n<pre><code class=\"language-console\">npm install --save-dev babel-plugin-syntax-flow babel-plugin-transform-flow-strip-types\n</code></pre>\n<p>et vous n'avez plus qu'à ajouter <code>\"syntax-flow\"</code> et <code>\"transform-flow-strip-types\"</code> à votre <code>.babelrc</code>.</p>\n<h2 id=\"mais-je-peux-pas-utiliser-babel-sur-mon-projet\"><a href=\"#mais-je-peux-pas-utiliser-babel-sur-mon-projet\"></a>Mais je peux pas utiliser babel sur mon projet</h2>\n<p>C'est ballot, mais tu peux quand même utiliser Flow avec de jolis commentaires.</p>\n<pre><code class=\"language-javascript\">/* @flow */\nconst add = (a/*: number */, b/*: number */)/*: number */ => {\n  return a + b\n}\n\nadd(1, 1)\n</code></pre>\n<p>Allez, maintenant pas d'excuse pour ne pas typer son JS, donc ce serait pas mal d'aller sur <a href=\"http://flowtype.org/docs/getting-started.html#_\">le site de Flow</a> pour en savoir un peu plus.</p>\n<p>Bisous bisous.</p>\n","rawBody":"\n```javascript\ndocument.body.firstChild.getBoundingClientRect()\n```\n\nCette hypothétique ligne de code ne fonctionne pas tout le temps.\n\nLa raison c'est que `element.firstChild` est un `Node` et que tous les `Node` ne possèdent pas la méthode `getBoundingClientRect`, que l'on trouve systématiquement sur les `Element`, une classe héritant de `Node`.\n\nCe type d'erreur est assez commun, et malheureusement JavaScript n'en fout pas une pour nous prévenir que *attention là ça peut merder*. Le langage préfère nous prévenir au *runtime*, quand c'est déjà trop tard, parce que le bug s'est produit.\n\nEt c'est parce que JavaScript est un langage … à typage **faible** et **dynamique**.\n\nFaible, parce que si l'on effectue une opération entre deux valeurs ayant des types incompatibles, JavaScript va essayer de convertir les types de la manière qui lui semble la moins déconnante.\n\nExemple *feat. la conscience de JavaScript™*\n\n```javascript\n\"1\" + 1\n// bon alors, vu que la string peut être à peu près n'importe quoi,\n// y'a un bon risque pour qu'une conversion en chiffre donne NaN,\n// donc on va plutôt convertir le chiffre en string et faire une\n// concaténation\n\"11\"\n```\n\n```javascript\n\"1\" * 1\n// putain mais qui a écrit cette merde encore ?\n// bon ben là si c'est une multiplication j'ai pas le choix,\n// on va convertir la string en nombre\n1\n```\n\nDynamique, en opposition à statique, parce que les tests de type sont faits au runtime.\n\n```javascript\nconst toLowerCase = (value) => {\n  return value.toLowerCase()\n}\n\ntoLowerCase(3)\n// bon alors, (3).toLowerCase c'est undefined\n// undefined c'est pas une fonction, ERREUR\n```\n\n## Comment on a fait jusque là ?\n\n### De la documentation\n\n```javascript\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nconst multiply = (a, b) => {\n  return a * b\n}\n```\n\nAh bah c'est bien, maintenant toute l'équipe sait quels types sont attendus. Ça n'empêche pas les erreurs au runtime mais au moins on est au courant.\n\n### Aller à fond dans le typage dynamique\n\n```javascript\nconst multiply = (a, b) => {\n  if(typeof a !== \"number\") {\n    throw new TypeError()\n  }\n  if(typeof b !== \"number\") {\n    throw new TypeError()\n  }\n  return a * b\n}\n```\n\nOn peut vérifier les types au runtime pour détecter les bugs possibles de manière plus drastique en dev, on se retrouvera toujours avec un souci en production, qui fera péter le comportement attendu.\n\n### Faire comme si c'était pas grave\n\n```javascript\nconst multiply = (a, b) => {\n  if(typeof a !== \"number\") {\n    a = 0\n  }\n  if(typeof b !== \"number\") {\n    b = 0\n  }\n  return a * b\n}\n```\n\nOn peut faire du \"defensive programming\". Au lieu de laisser le bug arriver, on le tolère. Dans 99% des cas, le résultat ne sera absolument pas celui que l'on attend, et on ne prévient même pas de quand ça foire.\n\n## Comment ça se passe ailleurs ?\n\nD'autres langages utilisent un typage statique, ce qui veut dire que le programme ne compilera pas si les types peuvent être incorrects.\n\n```ocaml\nlet value = \"1\";;\n\nvalue + 1;;\n```\n\nOCaml, quand vous essayez de faire tourner ce code va vous sortir un gros\n\n```\nFile \"test.ml\", line 3, characters 0-5:\nError: This expression has type string but an expression was expected of type\n         int\n```\n\n## Et comment peut-on avoir ça en JS ?\n\nC'est là que [Flow](http://flowtype.org) intervient. C'est un outil d'analyse statique de JS. Il détecte les incompatibilités de types au sein du code.\n\n```javascript\n/* @flow */\nconst multiply = (a, b) => {\n  return a * b\n}\n\nmultiply(1, \"1\")\n```\n\n```\n6: multiply(1, \"1\")\n   ^^^^^^^^^^^^^^^^ function call\n3:   return a * b\n                ^ string. This type is incompatible with\n3:   return a * b\n            ^^^^^ number\n```\n\nDans le cas précédent, Flow analyse le code et comprend qu'une opération entre `string` et `number` comporte une incompatibilité.\n\nDu coup, on peut avoir du code qui tourne du premier coup parce qu'il a éliminé toutes nos petites erreurs bêtes. En prime, ça permet d'arrêter de faire des tests unitaires bateau sur les types.\n\nFlow ajoute par ailleurs une syntaxe pour définir les types attendus dans une situation donnée. On utilise `:` suivi du type attendu.\n\n```javascript\n/* @flow */\n// les types built-ins sont compris naturellement par flow\nconst foo: string = \"foo\"\nconst bar: number = 3\n// on peut typer les valeurs contenues dans un array\nconst baz: Array<string> = [\"foo\", \"bar\"]\n// on peut typer des structures\nconst object: { foo: string, bar: number } = { foo, bar }\n// définir des valeurs litérales autorisées\nconst value: \"enabled\" | \"disabled\" = \"enabled\"\n// des unions de types\nconst stringOrNumber: string | number = \"foo\"\n\nfunction sum(array: Array<number>): number {\n  return array.reduce((acc, item) => acc + item, 0)\n}\n\nclass Person {\n  name: string;\n  constructor(name: string) { this.name = name }\n}\n// utiliser la relation prototypale pour typer une valeur\nconst person: Person = new Person(\"foo\")\n```\n\nFlow permet également de créer des alias de types, ce qui est essentiel pour les partager au sein d'une codebase. Une syntaxe pour importer les types de fichier existe également. Ces imports sont supprimés du build final.\n\n```javascript\n/* @flow */\nimport type { MediaType } from \"./MediaType\"\n\nexport type UserType = {\n  username: string,\n  firstName?: string,\n  lastName?: string,\n  email: string,\n  avatar: MediaType,\n}\n```\n\nLorsque l'on écrit du code qui se fout du type, on peut utiliser les *generics*, qui est une sorte de placeholder de type.\n\n```javascript\n/* @flow */\n// `T` est ici un type qui sera défini au call-site.\nfunction findLast<T> (\n  array: Array<T>,\n  func: (item: T, index: number, array: Array<T>) => any\n): null | T {\n  let index = array.length\n  while(--index >= 0) {\n    const item = array[index]\n    if(func(item, index, array)) {\n      return item\n    }\n  }\n  return null\n}\n\n// Flow sait que dans ce cas `T` est un nombre\nconst lastEvenNumber: ?number = findLast(\n  [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ],\n  (item) => item % 2 === 0\n)\n```\n\nFlow permet également de typer par structure partielle attendue.\n\n```javascript\n/* @flow */\n// l'inteface `named` permet de s'assurer que la valeur testée contient\n// une méthode `getName` retournant une `string`\ninterface named {\n  getName(): string,\n}\n\nclass Person {\n  name: string;\n  constructor(name: string) {\n    this.name = name\n  }\n  getName() {\n    return this.name\n  }\n}\n\nconst person: named = new Person(\"Luke Skywalker\")\n```\n\nReact est supporté directement, et Flow peut remplacer les `propTypes`.\n\n```javascript\n/* @flow */\nimport React, { Component } from \"react\"\nimport type { Element as ReactElement } from \"react\"\nimport type { UserType } from \"../types/UserType\"\n\n// <DefaultProps, Props, State>\nclass User extends Component<void, Props, void> {\n  render(): ReactElement {\n    return (\n      <div>\n        {user.username}\n      </div>\n    )\n  }\n}\n\ntype Props = {\n  user: UserType,\n}\n```\n\n## Mais c'est pas du JS valide\n\nPas de panique, pour ça il existe des plugins babel:\n\n```console\nnpm install --save-dev babel-plugin-syntax-flow babel-plugin-transform-flow-strip-types\n```\n\net vous n'avez plus qu'à ajouter `\"syntax-flow\"` et `\"transform-flow-strip-types\"` à votre `.babelrc`.\n\n## Mais je peux pas utiliser babel sur mon projet\n\nC'est ballot, mais tu peux quand même utiliser Flow avec de jolis commentaires.\n\n```javascript\n/* @flow */\nconst add = (a/*: number */, b/*: number */)/*: number */ => {\n  return a + b\n}\n\nadd(1, 1)\n```\n\nAllez, maintenant pas d'excuse pour ne pas typer son JS, donc ce serait pas mal d'aller sur [le site de Flow](http://flowtype.org/docs/getting-started.html#_) pour en savoir un peu plus.\n\nBisous bisous.\n","raw":"---\ndate: \"2016-06-07\"\ntitle: Introduction à Flow, pour du code qui tourne du premier coup\ntags:\n  - javascript\n  - flow\n  - type\nauthors:\n  - bloodyowl\n---\n\n```javascript\ndocument.body.firstChild.getBoundingClientRect()\n```\n\nCette hypothétique ligne de code ne fonctionne pas tout le temps.\n\nLa raison c'est que `element.firstChild` est un `Node` et que tous les `Node` ne possèdent pas la méthode `getBoundingClientRect`, que l'on trouve systématiquement sur les `Element`, une classe héritant de `Node`.\n\nCe type d'erreur est assez commun, et malheureusement JavaScript n'en fout pas une pour nous prévenir que *attention là ça peut merder*. Le langage préfère nous prévenir au *runtime*, quand c'est déjà trop tard, parce que le bug s'est produit.\n\nEt c'est parce que JavaScript est un langage … à typage **faible** et **dynamique**.\n\nFaible, parce que si l'on effectue une opération entre deux valeurs ayant des types incompatibles, JavaScript va essayer de convertir les types de la manière qui lui semble la moins déconnante.\n\nExemple *feat. la conscience de JavaScript™*\n\n```javascript\n\"1\" + 1\n// bon alors, vu que la string peut être à peu près n'importe quoi,\n// y'a un bon risque pour qu'une conversion en chiffre donne NaN,\n// donc on va plutôt convertir le chiffre en string et faire une\n// concaténation\n\"11\"\n```\n\n```javascript\n\"1\" * 1\n// putain mais qui a écrit cette merde encore ?\n// bon ben là si c'est une multiplication j'ai pas le choix,\n// on va convertir la string en nombre\n1\n```\n\nDynamique, en opposition à statique, parce que les tests de type sont faits au runtime.\n\n```javascript\nconst toLowerCase = (value) => {\n  return value.toLowerCase()\n}\n\ntoLowerCase(3)\n// bon alors, (3).toLowerCase c'est undefined\n// undefined c'est pas une fonction, ERREUR\n```\n\n## Comment on a fait jusque là ?\n\n### De la documentation\n\n```javascript\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nconst multiply = (a, b) => {\n  return a * b\n}\n```\n\nAh bah c'est bien, maintenant toute l'équipe sait quels types sont attendus. Ça n'empêche pas les erreurs au runtime mais au moins on est au courant.\n\n### Aller à fond dans le typage dynamique\n\n```javascript\nconst multiply = (a, b) => {\n  if(typeof a !== \"number\") {\n    throw new TypeError()\n  }\n  if(typeof b !== \"number\") {\n    throw new TypeError()\n  }\n  return a * b\n}\n```\n\nOn peut vérifier les types au runtime pour détecter les bugs possibles de manière plus drastique en dev, on se retrouvera toujours avec un souci en production, qui fera péter le comportement attendu.\n\n### Faire comme si c'était pas grave\n\n```javascript\nconst multiply = (a, b) => {\n  if(typeof a !== \"number\") {\n    a = 0\n  }\n  if(typeof b !== \"number\") {\n    b = 0\n  }\n  return a * b\n}\n```\n\nOn peut faire du \"defensive programming\". Au lieu de laisser le bug arriver, on le tolère. Dans 99% des cas, le résultat ne sera absolument pas celui que l'on attend, et on ne prévient même pas de quand ça foire.\n\n## Comment ça se passe ailleurs ?\n\nD'autres langages utilisent un typage statique, ce qui veut dire que le programme ne compilera pas si les types peuvent être incorrects.\n\n```ocaml\nlet value = \"1\";;\n\nvalue + 1;;\n```\n\nOCaml, quand vous essayez de faire tourner ce code va vous sortir un gros\n\n```\nFile \"test.ml\", line 3, characters 0-5:\nError: This expression has type string but an expression was expected of type\n         int\n```\n\n## Et comment peut-on avoir ça en JS ?\n\nC'est là que [Flow](http://flowtype.org) intervient. C'est un outil d'analyse statique de JS. Il détecte les incompatibilités de types au sein du code.\n\n```javascript\n/* @flow */\nconst multiply = (a, b) => {\n  return a * b\n}\n\nmultiply(1, \"1\")\n```\n\n```\n6: multiply(1, \"1\")\n   ^^^^^^^^^^^^^^^^ function call\n3:   return a * b\n                ^ string. This type is incompatible with\n3:   return a * b\n            ^^^^^ number\n```\n\nDans le cas précédent, Flow analyse le code et comprend qu'une opération entre `string` et `number` comporte une incompatibilité.\n\nDu coup, on peut avoir du code qui tourne du premier coup parce qu'il a éliminé toutes nos petites erreurs bêtes. En prime, ça permet d'arrêter de faire des tests unitaires bateau sur les types.\n\nFlow ajoute par ailleurs une syntaxe pour définir les types attendus dans une situation donnée. On utilise `:` suivi du type attendu.\n\n```javascript\n/* @flow */\n// les types built-ins sont compris naturellement par flow\nconst foo: string = \"foo\"\nconst bar: number = 3\n// on peut typer les valeurs contenues dans un array\nconst baz: Array<string> = [\"foo\", \"bar\"]\n// on peut typer des structures\nconst object: { foo: string, bar: number } = { foo, bar }\n// définir des valeurs litérales autorisées\nconst value: \"enabled\" | \"disabled\" = \"enabled\"\n// des unions de types\nconst stringOrNumber: string | number = \"foo\"\n\nfunction sum(array: Array<number>): number {\n  return array.reduce((acc, item) => acc + item, 0)\n}\n\nclass Person {\n  name: string;\n  constructor(name: string) { this.name = name }\n}\n// utiliser la relation prototypale pour typer une valeur\nconst person: Person = new Person(\"foo\")\n```\n\nFlow permet également de créer des alias de types, ce qui est essentiel pour les partager au sein d'une codebase. Une syntaxe pour importer les types de fichier existe également. Ces imports sont supprimés du build final.\n\n```javascript\n/* @flow */\nimport type { MediaType } from \"./MediaType\"\n\nexport type UserType = {\n  username: string,\n  firstName?: string,\n  lastName?: string,\n  email: string,\n  avatar: MediaType,\n}\n```\n\nLorsque l'on écrit du code qui se fout du type, on peut utiliser les *generics*, qui est une sorte de placeholder de type.\n\n```javascript\n/* @flow */\n// `T` est ici un type qui sera défini au call-site.\nfunction findLast<T> (\n  array: Array<T>,\n  func: (item: T, index: number, array: Array<T>) => any\n): null | T {\n  let index = array.length\n  while(--index >= 0) {\n    const item = array[index]\n    if(func(item, index, array)) {\n      return item\n    }\n  }\n  return null\n}\n\n// Flow sait que dans ce cas `T` est un nombre\nconst lastEvenNumber: ?number = findLast(\n  [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ],\n  (item) => item % 2 === 0\n)\n```\n\nFlow permet également de typer par structure partielle attendue.\n\n```javascript\n/* @flow */\n// l'inteface `named` permet de s'assurer que la valeur testée contient\n// une méthode `getName` retournant une `string`\ninterface named {\n  getName(): string,\n}\n\nclass Person {\n  name: string;\n  constructor(name: string) {\n    this.name = name\n  }\n  getName() {\n    return this.name\n  }\n}\n\nconst person: named = new Person(\"Luke Skywalker\")\n```\n\nReact est supporté directement, et Flow peut remplacer les `propTypes`.\n\n```javascript\n/* @flow */\nimport React, { Component } from \"react\"\nimport type { Element as ReactElement } from \"react\"\nimport type { UserType } from \"../types/UserType\"\n\n// <DefaultProps, Props, State>\nclass User extends Component<void, Props, void> {\n  render(): ReactElement {\n    return (\n      <div>\n        {user.username}\n      </div>\n    )\n  }\n}\n\ntype Props = {\n  user: UserType,\n}\n```\n\n## Mais c'est pas du JS valide\n\nPas de panique, pour ça il existe des plugins babel:\n\n```console\nnpm install --save-dev babel-plugin-syntax-flow babel-plugin-transform-flow-strip-types\n```\n\net vous n'avez plus qu'à ajouter `\"syntax-flow\"` et `\"transform-flow-strip-types\"` à votre `.babelrc`.\n\n## Mais je peux pas utiliser babel sur mon projet\n\nC'est ballot, mais tu peux quand même utiliser Flow avec de jolis commentaires.\n\n```javascript\n/* @flow */\nconst add = (a/*: number */, b/*: number */)/*: number */ => {\n  return a + b\n}\n\nadd(1, 1)\n```\n\nAllez, maintenant pas d'excuse pour ne pas typer son JS, donc ce serait pas mal d'aller sur [le site de Flow](http://flowtype.org/docs/getting-started.html#_) pour en savoir un peu plus.\n\nBisous bisous.\n","__filename":"fr/articles/js/flow/index.md","__url":"/fr/articles/js/flow/","__resourceUrl":"/fr/articles/js/flow/index.html","__dataUrl":"/fr/articles/js/flow/index.html.d528e58e3129e53e3af772523f9afe04.json"}