{"head":{"layout":"Post","comments":true,"date":"2015-12-14","title":"ES2016 (?): fonctions asynchrones (async/await)","tags":["JavaScript","ES2016"],"authors":["naholyr"],"description":"Aujourd'hui, une fonctionnalité peut-être abusivement taggée \"ES6\" puisqu'elle ne fait pas partie des propositions acceptées cette année…"},"body":"<p>Aujourd'hui, une fonctionnalité peut-être abusivement taggée \"ES6\" puisqu'elle ne\nfait pas partie des propositions acceptées cette année : les fonctions asynchrones (async/await).\nLa <a href=\"https://tc39.github.io/ecmascript-asyncawait/\">spécification</a> est encore au\nstade 3 (candidate) à l'heure de cet article. Mais il ne fait plus aucun doute\nqu'elle (ou une variante) fera partie de la spécification ES2016.</p>\n<h2 id=\"fonctions-asynchrones\"><a href=\"#fonctions-asynchrones\"></a>Fonctions asynchrones</h2>\n<p>Pour les traitements asynchrones, vous connaissez déjà\n<a href=\"/fr/articles/js/es2015/promises/\">les promesses</a> qui ont\névidemment remplacé les callbacks dans votre code. Si vous n'avez pas déjà fait\nla bascule vers les promesses (ne serait-ce que pour la propagation d'erreur),\n<a href=\"/fr/articles/js/es2015/generators/\">les générateurs</a> ont\ndû finir de vous convaincre grâce aux <a href=\"/fr/articles/js/es2015/generators/#use-case-co-routines\">coroutines</a>.</p>\n<p>Nous allons voir aujourd'hui une nouvelle manière de traiter les fonctions\nasynchrones. Mais ne jetez pas vos promesses, tout tourne encore autour d'elles.</p>\n<h2 id=\"exemple-de-traitement-asynchrone-promise\"><a href=\"#exemple-de-traitement-asynchrone-promise\"></a>Exemple de traitement asynchrone : Promise</h2>\n<p>Partons du programme suivant exécuté le\n6 décembre dernier dont l'API est basée sur les promesses :</p>\n<ul>\n<li>Il récupère tous les utilisateurs prénommés Nicolas</li>\n<li>Il envoie un mail à chacun pour souhaiter bonne fête</li>\n</ul>\n<pre><code class=\"language-js\">function sendEmails (query) {\n  const usersP = getUsers({firstName: 'Nicolas'})\n  // On récupère le champ \"email\" de tous les utilisateurs\n  const emailsP = usersP.then((users) => users.map(u => u.email))\n  // Pour chaque email…\n  const sentP = emailsP.then((emails) => emails.map((email) => {\n    // … on envoie un mail\n    return sendMail(email, 'Bonne fête')\n  }))\n  // On attend que tous les envois soient résolus\n  return Promise.all(sentP)\n}\n\nsendEmails({ firstName: 'Nicolas' })\n  .then(() => console.log('OK'))\n  .catch(() => console.error('FAIL'))\n</code></pre>\n<h2 id=\"nouveaux-mot-clés-async-et-await\"><a href=\"#nouveaux-mot-cl%C3%A9s-async-et-await\"></a>Nouveaux mot-clés <code>async</code> et <code>await</code></h2>\n<p>Une fonction peut être marquée comme asynchrone lorsque préfixée par <code>async</code> :</p>\n<pre><code class=\"language-js\">async function myFunction () {\n  // …\n}\n</code></pre>\n<p>Dans une fonction asynchrone, et <strong>seulement</strong> dans une fonction asynchrone, le\nmot-clé <code>await</code> devient disponible. Lorsqu'il est utilisé en préfixe d'une\npromesse, l'évaluation de l'expression est \"mise en pause\" jusqu'à la résolution\n(ou le rejet) de la promesse :</p>\n<pre><code class=\"language-js\">async function myFunction () {\n  await aPromise\n  // on n'arrivera à cette ligne que lorsque \"aPromise\" sera résolue\n}\n</code></pre>\n<p>Évidemment, l'expression a alors pour valeur celle de résolution de la\npromesse, et en cas d'erreur l'expression va lever (<code>throw</code>) une erreur :</p>\n<pre><code class=\"language-js\">async function myFunction () {\n  try {\n    const result = await aPromise\n    // Ici \"aPromise\" est résolue avec la valeur \"result\"\n  } catch (err) {\n    // Ici \"aPromise\" est rejetée avec l'erreur \"err\"\n  }\n\n  return 42 // cette ligne n'est atteinte qu'après résolution/rejet\n}\n</code></pre>\n<p>Concrètement, si vous vous souvenez de l'article sur les générateurs et de la\npartie sur les coroutines, remplacez <code>async function</code> par <code>function *</code> et\n<code>await</code> par <code>yield</code>, et vous avez compris le principe. ;)</p>\n<h2 id=\"notre-premier-exemple-avec-les-fonctions-asynchrones\"><a href=\"#notre-premier-exemple-avec-les-fonctions-asynchrones\"></a>Notre premier exemple, avec les fonctions asynchrones</h2>\n<p>Réécrivons notre premier exemple avec des fonctions asynchrones :</p>\n<pre><code class=\"language-js\">async function sendEmails (query) {\n  const users = await getUsers({firstName: 'Nicolas'})\n  const emails = users.map(u => u.email)\n  const sentP = emails.map((email) => sendMail(email, 'Bonne fête'))\n  return await Promise.all(sentP)\n}\n\n// Attention, on ne peut pas utiliser \"await\" hors d'une fonction \"async\"\n// il faut donc \"wrapper\" notre code autour d'une fonction asynchrone\nasync function main () {\n  try {\n    await sendEmails({ firstName: 'Nicolas' })\n    console.log('OK')\n  } catch (e) {\n    console.error('FAIL')\n  }\n}\n\nmain()\n</code></pre>\n<p>Mieux ? Moins bien ? Question de goût, mais on retrouve un code impératif plus\nhabituel.</p>\n<h2 id=\"attention-au-piège-de-lexécution-en-série\"><a href=\"#attention-au-pi%C3%A8ge-de-lex%C3%A9cution-en-s%C3%A9rie\"></a>Attention au piège de l'exécution en série !</h2>\n<p>Prenons l'exemple de requêtes qu'on exécute en concurrence avant d'utiliser\nleurs résultats :</p>\n<pre><code class=\"language-js\">const xP = getX() // Requête Ajax\nconst yP = getY() // Requête BDD\nconst resultP = Promise.all([xP, yP]).then(sum)\n</code></pre>\n<p>Dans cet exemple, les requêtes sont lancées, exécutées en parallèle puis leurs\nretours attendus avant de passer à la suite.</p>\n<p>Si on le traduit bêtement ainsi, on perd l'aspect concurrentiel :</p>\n<pre><code class=\"language-js\">const x = await getX() // Requête Ajax…\n// … requête terminée !\nconst y = await getY() // Requête BDD…\n// … requête terminée !\nconst result = sum([x, y])\n</code></pre>\n<p>Il faudra bien distinguer le moment où on souhaite <strong>démarrer l'action</strong> et le\nmoment où l'on souhaite <strong>disposer de son résultat</strong>, il y a plusieurs manières\nde résoudre le problème, qui dépendent essentiellement du goût du développeur ;)</p>\n<pre><code class=\"language-js\">const xP = getX() // Requête Ajax démarrée…\nconst yP = getY() // Requête BDD démarrée…\n\n// Version 1 :\nconst x = await xP // …requête Ajax terminée !\nconst y = await yP // …requête BDD terminée !\nconst result = sum([x, y])\n\n// Version 2 avec un tableau :\nconst vars = [await xP, await yP]\nconst result = sum(vars)\n\n// Version 3 avec Promise.all :\nconst vars = await Promise.all([xP, yP])\nconst result = sum(vars)\n</code></pre>\n<h2 id=\"et-aujourdhui\"><a href=\"#et-aujourdhui\"></a>Et aujourd'hui ?</h2>\n<p>On peut utiliser Babel pour compiler son code utilisant <code>async/await</code> en un\ncode basé sur les générateurs : il vous suffira d'ajouter les plugins Babel\n<code>syntax-async-functions</code> et <code>transform-async-to-generator</code> (attention à\ninclure <code>babel-polyfill</code> en fichier d'entrée).</p>\n<h2 id=\"conclusion\"><a href=\"#conclusion\"></a>Conclusion</h2>\n<p>Grâce aux fonctions asynchrones, la refactorisation d'un code bloquant vers un\ncode non bloquant devient vraiment aisée. Les promesses simplifiaient déjà le\nprocessus mais on n'était pas débarassé des callbacks. Là, à deux mot-clés près,\nc'est exactement la même chose !</p>\n<p>D'un certain côté, c'est un retour en arrière : l'asynchrone mène aux promesses,\nqui mènent à la programmation fonctionnelle, qui apporte tant de bienfaits… Il\ns'agira de trouver le bon équilibre, je ne suis pas convaincu d'abandonner mes\n<code>.then</code> tout de suite, mais il est certain que c'est une véritable avancée\npour ce langage : la courbe d'apprentissage des traitements asynchrones va être\ndrastiquement aplanie ;)</p>\n","rawBody":"\nAujourd'hui, une fonctionnalité peut-être abusivement taggée \"ES6\" puisqu'elle ne\nfait pas partie des propositions acceptées cette année : les fonctions asynchrones (async/await).\nLa [spécification](https://tc39.github.io/ecmascript-asyncawait/) est encore au\nstade 3 (candidate) à l'heure de cet article. Mais il ne fait plus aucun doute\nqu'elle (ou une variante) fera partie de la spécification ES2016.\n\n## Fonctions asynchrones\n\nPour les traitements asynchrones, vous connaissez déjà\n[les promesses](/fr/articles/js/es2015/promises/) qui ont\névidemment remplacé les callbacks dans votre code. Si vous n'avez pas déjà fait\nla bascule vers les promesses (ne serait-ce que pour la propagation d'erreur),\n[les générateurs](/fr/articles/js/es2015/generators/) ont\ndû finir de vous convaincre grâce aux [coroutines](/fr/articles/js/es2015/generators/#use-case-co-routines).\n\nNous allons voir aujourd'hui une nouvelle manière de traiter les fonctions\nasynchrones. Mais ne jetez pas vos promesses, tout tourne encore autour d'elles.\n\n## Exemple de traitement asynchrone : Promise\n\nPartons du programme suivant exécuté le\n6 décembre dernier dont l'API est basée sur les promesses :\n\n* Il récupère tous les utilisateurs prénommés Nicolas\n* Il envoie un mail à chacun pour souhaiter bonne fête\n\n```js\nfunction sendEmails (query) {\n  const usersP = getUsers({firstName: 'Nicolas'})\n  // On récupère le champ \"email\" de tous les utilisateurs\n  const emailsP = usersP.then((users) => users.map(u => u.email))\n  // Pour chaque email…\n  const sentP = emailsP.then((emails) => emails.map((email) => {\n    // … on envoie un mail\n    return sendMail(email, 'Bonne fête')\n  }))\n  // On attend que tous les envois soient résolus\n  return Promise.all(sentP)\n}\n\nsendEmails({ firstName: 'Nicolas' })\n  .then(() => console.log('OK'))\n  .catch(() => console.error('FAIL'))\n```\n\n## Nouveaux mot-clés ``async`` et ``await``\n\nUne fonction peut être marquée comme asynchrone lorsque préfixée par ``async`` :\n\n```js\nasync function myFunction () {\n  // …\n}\n```\n\nDans une fonction asynchrone, et **seulement** dans une fonction asynchrone, le\nmot-clé ``await`` devient disponible. Lorsqu'il est utilisé en préfixe d'une\npromesse, l'évaluation de l'expression est \"mise en pause\" jusqu'à la résolution\n(ou le rejet) de la promesse :\n\n```js\nasync function myFunction () {\n  await aPromise\n  // on n'arrivera à cette ligne que lorsque \"aPromise\" sera résolue\n}\n```\n\nÉvidemment, l'expression a alors pour valeur celle de résolution de la\npromesse, et en cas d'erreur l'expression va lever (``throw``) une erreur :\n\n```js\nasync function myFunction () {\n  try {\n    const result = await aPromise\n    // Ici \"aPromise\" est résolue avec la valeur \"result\"\n  } catch (err) {\n    // Ici \"aPromise\" est rejetée avec l'erreur \"err\"\n  }\n\n  return 42 // cette ligne n'est atteinte qu'après résolution/rejet\n}\n```\n\nConcrètement, si vous vous souvenez de l'article sur les générateurs et de la\npartie sur les coroutines, remplacez ``async function`` par ``function *`` et\n``await`` par ``yield``, et vous avez compris le principe. ;)\n\n## Notre premier exemple, avec les fonctions asynchrones\n\nRéécrivons notre premier exemple avec des fonctions asynchrones :\n\n```js\nasync function sendEmails (query) {\n  const users = await getUsers({firstName: 'Nicolas'})\n  const emails = users.map(u => u.email)\n  const sentP = emails.map((email) => sendMail(email, 'Bonne fête'))\n  return await Promise.all(sentP)\n}\n\n// Attention, on ne peut pas utiliser \"await\" hors d'une fonction \"async\"\n// il faut donc \"wrapper\" notre code autour d'une fonction asynchrone\nasync function main () {\n  try {\n    await sendEmails({ firstName: 'Nicolas' })\n    console.log('OK')\n  } catch (e) {\n    console.error('FAIL')\n  }\n}\n\nmain()\n```\n\nMieux ? Moins bien ? Question de goût, mais on retrouve un code impératif plus\nhabituel.\n\n## Attention au piège de l'exécution en série !\n\nPrenons l'exemple de requêtes qu'on exécute en concurrence avant d'utiliser\nleurs résultats :\n\n```js\nconst xP = getX() // Requête Ajax\nconst yP = getY() // Requête BDD\nconst resultP = Promise.all([xP, yP]).then(sum)\n```\n\nDans cet exemple, les requêtes sont lancées, exécutées en parallèle puis leurs\nretours attendus avant de passer à la suite.\n\nSi on le traduit bêtement ainsi, on perd l'aspect concurrentiel :\n\n```js\nconst x = await getX() // Requête Ajax…\n// … requête terminée !\nconst y = await getY() // Requête BDD…\n// … requête terminée !\nconst result = sum([x, y])\n```\n\nIl faudra bien distinguer le moment où on souhaite **démarrer l'action** et le\nmoment où l'on souhaite **disposer de son résultat**, il y a plusieurs manières\nde résoudre le problème, qui dépendent essentiellement du goût du développeur ;)\n\n```js\nconst xP = getX() // Requête Ajax démarrée…\nconst yP = getY() // Requête BDD démarrée…\n\n// Version 1 :\nconst x = await xP // …requête Ajax terminée !\nconst y = await yP // …requête BDD terminée !\nconst result = sum([x, y])\n\n// Version 2 avec un tableau :\nconst vars = [await xP, await yP]\nconst result = sum(vars)\n\n// Version 3 avec Promise.all :\nconst vars = await Promise.all([xP, yP])\nconst result = sum(vars)\n```\n\n## Et aujourd'hui ?\n\nOn peut utiliser Babel pour compiler son code utilisant ``async/await`` en un\ncode basé sur les générateurs : il vous suffira d'ajouter les plugins Babel\n``syntax-async-functions`` et ``transform-async-to-generator`` (attention à\ninclure ``babel-polyfill`` en fichier d'entrée).\n\n## Conclusion\n\nGrâce aux fonctions asynchrones, la refactorisation d'un code bloquant vers un\ncode non bloquant devient vraiment aisée. Les promesses simplifiaient déjà le\nprocessus mais on n'était pas débarassé des callbacks. Là, à deux mot-clés près,\nc'est exactement la même chose !\n\nD'un certain côté, c'est un retour en arrière : l'asynchrone mène aux promesses,\nqui mènent à la programmation fonctionnelle, qui apporte tant de bienfaits… Il\ns'agira de trouver le bon équilibre, je ne suis pas convaincu d'abandonner mes\n``.then`` tout de suite, mais il est certain que c'est une véritable avancée\npour ce langage : la courbe d'apprentissage des traitements asynchrones va être\ndrastiquement aplanie ;)\n","raw":"---\ndate: \"2015-12-14\"\ntitle: \"ES2016 (?): fonctions asynchrones (async/await)\"\ntags:\n  - JavaScript\n  - ES2016\nauthors:\n  - naholyr\n---\n\nAujourd'hui, une fonctionnalité peut-être abusivement taggée \"ES6\" puisqu'elle ne\nfait pas partie des propositions acceptées cette année : les fonctions asynchrones (async/await).\nLa [spécification](https://tc39.github.io/ecmascript-asyncawait/) est encore au\nstade 3 (candidate) à l'heure de cet article. Mais il ne fait plus aucun doute\nqu'elle (ou une variante) fera partie de la spécification ES2016.\n\n## Fonctions asynchrones\n\nPour les traitements asynchrones, vous connaissez déjà\n[les promesses](/fr/articles/js/es2015/promises/) qui ont\névidemment remplacé les callbacks dans votre code. Si vous n'avez pas déjà fait\nla bascule vers les promesses (ne serait-ce que pour la propagation d'erreur),\n[les générateurs](/fr/articles/js/es2015/generators/) ont\ndû finir de vous convaincre grâce aux [coroutines](/fr/articles/js/es2015/generators/#use-case-co-routines).\n\nNous allons voir aujourd'hui une nouvelle manière de traiter les fonctions\nasynchrones. Mais ne jetez pas vos promesses, tout tourne encore autour d'elles.\n\n## Exemple de traitement asynchrone : Promise\n\nPartons du programme suivant exécuté le\n6 décembre dernier dont l'API est basée sur les promesses :\n\n* Il récupère tous les utilisateurs prénommés Nicolas\n* Il envoie un mail à chacun pour souhaiter bonne fête\n\n```js\nfunction sendEmails (query) {\n  const usersP = getUsers({firstName: 'Nicolas'})\n  // On récupère le champ \"email\" de tous les utilisateurs\n  const emailsP = usersP.then((users) => users.map(u => u.email))\n  // Pour chaque email…\n  const sentP = emailsP.then((emails) => emails.map((email) => {\n    // … on envoie un mail\n    return sendMail(email, 'Bonne fête')\n  }))\n  // On attend que tous les envois soient résolus\n  return Promise.all(sentP)\n}\n\nsendEmails({ firstName: 'Nicolas' })\n  .then(() => console.log('OK'))\n  .catch(() => console.error('FAIL'))\n```\n\n## Nouveaux mot-clés ``async`` et ``await``\n\nUne fonction peut être marquée comme asynchrone lorsque préfixée par ``async`` :\n\n```js\nasync function myFunction () {\n  // …\n}\n```\n\nDans une fonction asynchrone, et **seulement** dans une fonction asynchrone, le\nmot-clé ``await`` devient disponible. Lorsqu'il est utilisé en préfixe d'une\npromesse, l'évaluation de l'expression est \"mise en pause\" jusqu'à la résolution\n(ou le rejet) de la promesse :\n\n```js\nasync function myFunction () {\n  await aPromise\n  // on n'arrivera à cette ligne que lorsque \"aPromise\" sera résolue\n}\n```\n\nÉvidemment, l'expression a alors pour valeur celle de résolution de la\npromesse, et en cas d'erreur l'expression va lever (``throw``) une erreur :\n\n```js\nasync function myFunction () {\n  try {\n    const result = await aPromise\n    // Ici \"aPromise\" est résolue avec la valeur \"result\"\n  } catch (err) {\n    // Ici \"aPromise\" est rejetée avec l'erreur \"err\"\n  }\n\n  return 42 // cette ligne n'est atteinte qu'après résolution/rejet\n}\n```\n\nConcrètement, si vous vous souvenez de l'article sur les générateurs et de la\npartie sur les coroutines, remplacez ``async function`` par ``function *`` et\n``await`` par ``yield``, et vous avez compris le principe. ;)\n\n## Notre premier exemple, avec les fonctions asynchrones\n\nRéécrivons notre premier exemple avec des fonctions asynchrones :\n\n```js\nasync function sendEmails (query) {\n  const users = await getUsers({firstName: 'Nicolas'})\n  const emails = users.map(u => u.email)\n  const sentP = emails.map((email) => sendMail(email, 'Bonne fête'))\n  return await Promise.all(sentP)\n}\n\n// Attention, on ne peut pas utiliser \"await\" hors d'une fonction \"async\"\n// il faut donc \"wrapper\" notre code autour d'une fonction asynchrone\nasync function main () {\n  try {\n    await sendEmails({ firstName: 'Nicolas' })\n    console.log('OK')\n  } catch (e) {\n    console.error('FAIL')\n  }\n}\n\nmain()\n```\n\nMieux ? Moins bien ? Question de goût, mais on retrouve un code impératif plus\nhabituel.\n\n## Attention au piège de l'exécution en série !\n\nPrenons l'exemple de requêtes qu'on exécute en concurrence avant d'utiliser\nleurs résultats :\n\n```js\nconst xP = getX() // Requête Ajax\nconst yP = getY() // Requête BDD\nconst resultP = Promise.all([xP, yP]).then(sum)\n```\n\nDans cet exemple, les requêtes sont lancées, exécutées en parallèle puis leurs\nretours attendus avant de passer à la suite.\n\nSi on le traduit bêtement ainsi, on perd l'aspect concurrentiel :\n\n```js\nconst x = await getX() // Requête Ajax…\n// … requête terminée !\nconst y = await getY() // Requête BDD…\n// … requête terminée !\nconst result = sum([x, y])\n```\n\nIl faudra bien distinguer le moment où on souhaite **démarrer l'action** et le\nmoment où l'on souhaite **disposer de son résultat**, il y a plusieurs manières\nde résoudre le problème, qui dépendent essentiellement du goût du développeur ;)\n\n```js\nconst xP = getX() // Requête Ajax démarrée…\nconst yP = getY() // Requête BDD démarrée…\n\n// Version 1 :\nconst x = await xP // …requête Ajax terminée !\nconst y = await yP // …requête BDD terminée !\nconst result = sum([x, y])\n\n// Version 2 avec un tableau :\nconst vars = [await xP, await yP]\nconst result = sum(vars)\n\n// Version 3 avec Promise.all :\nconst vars = await Promise.all([xP, yP])\nconst result = sum(vars)\n```\n\n## Et aujourd'hui ?\n\nOn peut utiliser Babel pour compiler son code utilisant ``async/await`` en un\ncode basé sur les générateurs : il vous suffira d'ajouter les plugins Babel\n``syntax-async-functions`` et ``transform-async-to-generator`` (attention à\ninclure ``babel-polyfill`` en fichier d'entrée).\n\n## Conclusion\n\nGrâce aux fonctions asynchrones, la refactorisation d'un code bloquant vers un\ncode non bloquant devient vraiment aisée. Les promesses simplifiaient déjà le\nprocessus mais on n'était pas débarassé des callbacks. Là, à deux mot-clés près,\nc'est exactement la même chose !\n\nD'un certain côté, c'est un retour en arrière : l'asynchrone mène aux promesses,\nqui mènent à la programmation fonctionnelle, qui apporte tant de bienfaits… Il\ns'agira de trouver le bon équilibre, je ne suis pas convaincu d'abandonner mes\n``.then`` tout de suite, mais il est certain que c'est une véritable avancée\npour ce langage : la courbe d'apprentissage des traitements asynchrones va être\ndrastiquement aplanie ;)\n","__filename":"fr/articles/js/es2016/async-await.md","__url":"/fr/articles/js/es2016/async-await/","__resourceUrl":"/fr/articles/js/es2016/async-await/index.html","__dataUrl":"/fr/articles/js/es2016/async-await/index.html.f457c32ca4c436f1a2da04208f80b395.json"}