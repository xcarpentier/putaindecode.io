{"head":{"layout":"Post","comments":true,"date":"2015-12-15","title":"ES6, ES2015 : Arrow functions","tags":["JavaScript","ES6","ES2015"],"authors":["MoOx"],"description":"ES2015 brings us some new syntax sugar that will likely make you stop using Function.prototype.bind(). Arrow functions are just a function…"},"body":"<p>ES2015 brings us some new syntax sugar that will likely make you stop using\n<code>Function.prototype.bind()</code>.</p>\n<p>Arrow functions are just a function shorthand using the <code>=></code> syntax.</p>\n<pre><code class=\"language-js\">// es5\nvar myFn = function(x) {\n    return x + 1\n}\n\n// es6\nconst myFn = (x) => {\n  return x + 1\n}\n</code></pre>\n<p>Arrow functions are syntactically similar to the related feature that exists in\nother languages like CoffeeScript, Java (8+), C#…</p>\n<p>They support both expression and statement bodies.\nIn our example above, we have seen a classic statement.\nBut for simple function, we can use an simple expression, to make things shorter.\nThat means that the previous example can be also written like this:</p>\n<pre><code class=\"language-js\">const myFn = (x) => x + 1\n</code></pre>\n<p>Note that when you have only one argument, you can omit parenthesis around it.\nSo we can also wrote the example like this</p>\n<pre><code class=\"language-js\">const myFn = x => x + 1\n</code></pre>\n<p>And you can also wrap the body in parenthesis if you want to make a multiline expression</p>\n<pre><code class=\"language-js\">const myFn = x => (\n  x +\n  1 // that can be multilines, you can imagine some JSX here ;)\n)\n</code></pre>\n<p>So this examples are all the same :</p>\n<pre><code class=\"language-js\">const myFn = (x) => {\n  return x + 1\n}\n// ===\nconst myFn = (x) => x + 1\n// ===\nconst myFn = x => x + 1\n// ===\nconst myFn = x => (x + 1)\n</code></pre>\n<p>In practice you will use this small functions in method like Array\nreduce/filter/map etc.</p>\n<pre><code class=\"language-js\">const nums = [1, 2, 3, 4, 5]\nconst odds = nums.filter(v => v%2) // [1, 3, 5]\nconst oddsSum = odds.reduce((sum, v) => sum+v, 0) // 9\n</code></pre>\n<h2 id=\"arrow-functions-dont-have-a-this\"><a href=\"#arrow-functions-dont-have-a-this\"></a>Arrow functions don’t have a <code>this</code></h2>\n<p>Yes your read correctly: unlike functions, arrows function share the same lexical this as their surrounding code.\nSo that means the <code>this</code> you might use use in the body of an arrow function refer to the parent scope:</p>\n<pre><code class=\"language-js\">const Someone = {\n  name: “MoOx”,\n  friends: [], // he got no friends atm :(\n  printFriends() {\n    this._friends.forEach(f =>\n      console.log(this._name + \" knows \" + f)\n      // `this` is not the function of the forEach !\n    )\n  }\n}\n</code></pre>\n<p>By reading this code, you might understand that you are likely to stop using\n<code>bind()</code>:</p>\n<pre><code class=\"language-js\">import React, { Component } from “react”\nclass Stuff extends Component {\n\n  // old way\n  onClick(e) {\n    this.setState({ omg: false })\n  }\n\n  render() {\n    return (\n      &#x3C;div>\n        { /* old way */ }\n        &#x3C;button onClick={ this.onClick.bind(this) }>\n          Old binded call\n        &#x3C;/button>\n\n        { /* LOOK MA', NO BIND ! */ }\n        &#x3C;button onClick={ (e) => this.onClick(e) }>\n          I don’t need `bind` anymore !\n        &#x3C;/button>\n\n        { /* Simpler way */ }\n        &#x3C;button onClick={ (e) => this.setState({ omg: true }) }>\n          Hell yeah\n        &#x3C;/button>\n      &#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<h2 id=\"note-about-expression-body-and-object\"><a href=\"#note-about-expression-body-and-object\"></a>Note about expression body and Object</h2>\n<p>If you want to return an object you might be surprised to get <code>undefined</code>\nwith this code:</p>\n<pre><code class=\"language-js\">const aFn = (obj) => {key: obj.value}\n</code></pre>\n<p>Indeed the above snippet could be translated into ES5 this way:</p>\n<pre><code class=\"language-js\">var aFn = function (obj) {\n  key:         // Defines a label named `key`\n    obj.value  // Gets `obj.value`\n               // Implicit returns `undefined`\n}\n</code></pre>\n<p>Keep in mind that in this context, a brace is to start a statement body, not an\nobject.\nSo you will need this:</p>\n<pre><code class=\"language-js\">const aFn = (obj) => { return {key: obj.value} }\n</code></pre>\n<p>But wait, there is a trick: a stupid couple of parenthesis.</p>\n<pre><code class=\"language-js\">const aFn = (obj) => ({key: obj.value}) // It works!\n</code></pre>\n<h2 id=\"conclusion\"><a href=\"#conclusion\"></a>Conclusion</h2>\n<p>Take a look to the\n<a href=\"https://kangax.github.io/compat-table/es6/#test-arrow_functions\">compatibility table</a>.\nYou will see that arrow functions are already supported by most browsers but you\nmight need <a href=\"http://babeljs.io\">Babel</a> to use it today.</p>\n<p>You will probably use this more and more.\nEven if <code>function</code> keyword is not dead, arrow functions <code>=></code> are probably\ngoing to be a thing !</p>\n","rawBody":"\nES2015 brings us some new syntax sugar that will likely make you stop using\n``Function.prototype.bind()``.\n\nArrow functions are just a function shorthand using the `=>` syntax.\n\n```js\n// es5\nvar myFn = function(x) {\n    return x + 1\n}\n\n// es6\nconst myFn = (x) => {\n  return x + 1\n}\n```\n\nArrow functions are syntactically similar to the related feature that exists in\nother languages like CoffeeScript, Java (8+), C#…\n\nThey support both expression and statement bodies.\nIn our example above, we have seen a classic statement.\nBut for simple function, we can use an simple expression, to make things shorter.\nThat means that the previous example can be also written like this:\n\n```js\nconst myFn = (x) => x + 1\n```\n\nNote that when you have only one argument, you can omit parenthesis around it.\nSo we can also wrote the example like this\n\n```js\nconst myFn = x => x + 1\n```\n\nAnd you can also wrap the body in parenthesis if you want to make a multiline expression\n\n```js\nconst myFn = x => (\n  x +\n  1 // that can be multilines, you can imagine some JSX here ;)\n)\n```\n\nSo this examples are all the same :\n\n```js\nconst myFn = (x) => {\n  return x + 1\n}\n// ===\nconst myFn = (x) => x + 1\n// ===\nconst myFn = x => x + 1\n// ===\nconst myFn = x => (x + 1)\n```\n\nIn practice you will use this small functions in method like Array\nreduce/filter/map etc.\n\n```js\nconst nums = [1, 2, 3, 4, 5]\nconst odds = nums.filter(v => v%2) // [1, 3, 5]\nconst oddsSum = odds.reduce((sum, v) => sum+v, 0) // 9\n```\n\n## Arrow functions don’t have a `this`\n\nYes your read correctly: unlike functions, arrows function share the same lexical this as their surrounding code.\nSo that means the `this` you might use use in the body of an arrow function refer to the parent scope:\n\n```js\nconst Someone = {\n  name: “MoOx”,\n  friends: [], // he got no friends atm :(\n  printFriends() {\n    this._friends.forEach(f =>\n      console.log(this._name + \" knows \" + f)\n      // `this` is not the function of the forEach !\n    )\n  }\n}\n```\n\nBy reading this code, you might understand that you are likely to stop using\n``bind()``:\n\n```js\nimport React, { Component } from “react”\nclass Stuff extends Component {\n\n  // old way\n  onClick(e) {\n    this.setState({ omg: false })\n  }\n\n  render() {\n    return (\n      <div>\n        { /* old way */ }\n        <button onClick={ this.onClick.bind(this) }>\n          Old binded call\n        </button>\n\n        { /* LOOK MA', NO BIND ! */ }\n        <button onClick={ (e) => this.onClick(e) }>\n          I don’t need `bind` anymore !\n        </button>\n\n        { /* Simpler way */ }\n        <button onClick={ (e) => this.setState({ omg: true }) }>\n          Hell yeah\n        </button>\n      </div>\n    )\n  }\n}\n```\n\n## Note about expression body and Object\n\nIf you want to return an object you might be surprised to get `undefined`\nwith this code:\n\n```js\nconst aFn = (obj) => {key: obj.value}\n```\n\nIndeed the above snippet could be translated into ES5 this way:\n\n```js\nvar aFn = function (obj) {\n  key:         // Defines a label named `key`\n    obj.value  // Gets `obj.value`\n               // Implicit returns `undefined`\n}\n```\n\nKeep in mind that in this context, a brace is to start a statement body, not an\nobject.\nSo you will need this:\n\n```js\nconst aFn = (obj) => { return {key: obj.value} }\n```\n\nBut wait, there is a trick: a stupid couple of parenthesis.\n\n```js\nconst aFn = (obj) => ({key: obj.value}) // It works!\n```\n\n## Conclusion\n\nTake a look to the\n[compatibility table](https://kangax.github.io/compat-table/es6/#test-arrow_functions).\nYou will see that arrow functions are already supported by most browsers but you\nmight need [Babel](http://babeljs.io) to use it today.\n\nYou will probably use this more and more.\nEven if `function` keyword is not dead, arrow functions `=>` are probably\ngoing to be a thing !\n","raw":"---\ndate: \"2015-12-15\"\ntitle: \"ES6, ES2015 : Arrow functions\"\ntags:\n  - JavaScript\n  - ES6\n  - ES2015\nauthors:\n  - MoOx\n---\n\nES2015 brings us some new syntax sugar that will likely make you stop using\n``Function.prototype.bind()``.\n\nArrow functions are just a function shorthand using the `=>` syntax.\n\n```js\n// es5\nvar myFn = function(x) {\n    return x + 1\n}\n\n// es6\nconst myFn = (x) => {\n  return x + 1\n}\n```\n\nArrow functions are syntactically similar to the related feature that exists in\nother languages like CoffeeScript, Java (8+), C#…\n\nThey support both expression and statement bodies.\nIn our example above, we have seen a classic statement.\nBut for simple function, we can use an simple expression, to make things shorter.\nThat means that the previous example can be also written like this:\n\n```js\nconst myFn = (x) => x + 1\n```\n\nNote that when you have only one argument, you can omit parenthesis around it.\nSo we can also wrote the example like this\n\n```js\nconst myFn = x => x + 1\n```\n\nAnd you can also wrap the body in parenthesis if you want to make a multiline expression\n\n```js\nconst myFn = x => (\n  x +\n  1 // that can be multilines, you can imagine some JSX here ;)\n)\n```\n\nSo this examples are all the same :\n\n```js\nconst myFn = (x) => {\n  return x + 1\n}\n// ===\nconst myFn = (x) => x + 1\n// ===\nconst myFn = x => x + 1\n// ===\nconst myFn = x => (x + 1)\n```\n\nIn practice you will use this small functions in method like Array\nreduce/filter/map etc.\n\n```js\nconst nums = [1, 2, 3, 4, 5]\nconst odds = nums.filter(v => v%2) // [1, 3, 5]\nconst oddsSum = odds.reduce((sum, v) => sum+v, 0) // 9\n```\n\n## Arrow functions don’t have a `this`\n\nYes your read correctly: unlike functions, arrows function share the same lexical this as their surrounding code.\nSo that means the `this` you might use use in the body of an arrow function refer to the parent scope:\n\n```js\nconst Someone = {\n  name: “MoOx”,\n  friends: [], // he got no friends atm :(\n  printFriends() {\n    this._friends.forEach(f =>\n      console.log(this._name + \" knows \" + f)\n      // `this` is not the function of the forEach !\n    )\n  }\n}\n```\n\nBy reading this code, you might understand that you are likely to stop using\n``bind()``:\n\n```js\nimport React, { Component } from “react”\nclass Stuff extends Component {\n\n  // old way\n  onClick(e) {\n    this.setState({ omg: false })\n  }\n\n  render() {\n    return (\n      <div>\n        { /* old way */ }\n        <button onClick={ this.onClick.bind(this) }>\n          Old binded call\n        </button>\n\n        { /* LOOK MA', NO BIND ! */ }\n        <button onClick={ (e) => this.onClick(e) }>\n          I don’t need `bind` anymore !\n        </button>\n\n        { /* Simpler way */ }\n        <button onClick={ (e) => this.setState({ omg: true }) }>\n          Hell yeah\n        </button>\n      </div>\n    )\n  }\n}\n```\n\n## Note about expression body and Object\n\nIf you want to return an object you might be surprised to get `undefined`\nwith this code:\n\n```js\nconst aFn = (obj) => {key: obj.value}\n```\n\nIndeed the above snippet could be translated into ES5 this way:\n\n```js\nvar aFn = function (obj) {\n  key:         // Defines a label named `key`\n    obj.value  // Gets `obj.value`\n               // Implicit returns `undefined`\n}\n```\n\nKeep in mind that in this context, a brace is to start a statement body, not an\nobject.\nSo you will need this:\n\n```js\nconst aFn = (obj) => { return {key: obj.value} }\n```\n\nBut wait, there is a trick: a stupid couple of parenthesis.\n\n```js\nconst aFn = (obj) => ({key: obj.value}) // It works!\n```\n\n## Conclusion\n\nTake a look to the\n[compatibility table](https://kangax.github.io/compat-table/es6/#test-arrow_functions).\nYou will see that arrow functions are already supported by most browsers but you\nmight need [Babel](http://babeljs.io) to use it today.\n\nYou will probably use this more and more.\nEven if `function` keyword is not dead, arrow functions `=>` are probably\ngoing to be a thing !\n","__filename":"en/articles/js/es2015/arrow-functions.md","__url":"/en/articles/js/es2015/arrow-functions/","__resourceUrl":"/en/articles/js/es2015/arrow-functions/index.html","__dataUrl":"/en/articles/js/es2015/arrow-functions/index.html.6fa5274ea398eb1a69f1c8cc50c5ef12.json"}