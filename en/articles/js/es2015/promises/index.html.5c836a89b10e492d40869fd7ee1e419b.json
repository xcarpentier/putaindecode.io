{"head":{"layout":"Post","comments":true,"date":"2015-12-06","title":"ES6, ES2015 : Promises","tags":["JavaScript","ES6","ES2015"],"authors":["Uhsac"],"translators":["MoOx"],"description":"With ES2015, you can now very easily write asynchronous code thanks to the promises. The concept of promises exists is not new in theâ€¦"},"body":"<p>With ES2015, you can now very easily write asynchronous code thanks to the\npromises.\nThe concept of promises exists is not new in the JavaScript world, but now\nwe got an official feature!</p>\n<h2 id=\"whats-a-promise\"><a href=\"#whats-a-promise\"></a>What's a promise?</h2>\n<p>It's a promise of an incoming value, not available yet. It's a promise so it can\nbe fulfilled or not (rejected). If fulfilled, it will give us the the value we\nwere waiting for. If rejected, we will get the error so we can handle it.</p>\n<p>This mechanism allows to avoid the callback hell :</p>\n<pre><code class=\"language-js\">// With callbacks.\n// Let's say that all those function are doing async tasks (like http or\n// database request, fs read...)\nconst functionWithCallback1 = (callback) => callback('test', undefined)\nconst functionWithCallback2 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback3 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback4 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback5 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback6 = (arg, callback) => callback(arg, undefined)\n\nfunctionWithCallback1((result1, err) => {\n  if (err) {\n    throw err\n  }\n  functionWithCallback2(result1, (result2, err) => {\n    if (err) {\n      throw err\n    }\n    functionWithCallback3(result2, (result3, err) => {\n      if (err) {\n        throw err\n      }\n      functionWithCallback4(result3, (result4, err) => {\n        if (err) {\n          throw err\n        }\n        functionWithCallback5(result4, (result5, err) => {\n          if (err) {\n            throw err\n          }\n          functionWithCallback6(result5, (result6, err) => {\n            if (err) {\n              throw err\n            }\n            console.log(`Example with callbacks: ${result6}`)\n          })\n        })\n      })\n    })\n  })\n})\n\n// Now the same thing with promises\nconst functionWithPromise1 = () => Promise.resolve('test')\nconst functionWithPromise2 = (arg) => Promise.resolve(arg)\nconst functionWithPromise3 = (arg) => Promise.resolve(arg)\nconst functionWithPromise4 = (arg) => Promise.resolve(arg)\nconst functionWithPromise5 = (arg) => Promise.resolve(arg)\nconst functionWithPromise6 = (arg) => Promise.resolve(arg)\n\nfunctionWithPromise1()\n  .then(functionWithPromise2)\n  .then(functionWithPromise3)\n  .then(functionWithPromise4)\n  .then(functionWithPromise5)\n  .then(functionWithPromise6)\n  .then(result => console.log(`Example with promises: ${result}`))\n  .catch(err => {\n    throw err\n  })\n</code></pre>\n<p>As you can see, example with promises is clear and more concise.</p>\n<h2 id=\"thats-cool-how-can-i-use-promises\"><a href=\"#thats-cool-how-can-i-use-promises\"></a>That's cool. How can I use promises?</h2>\n<p>A promise can have different status:</p>\n<ul>\n<li>in progress: value is not ready yet</li>\n<li>resolved: value is here, we can use it</li>\n<li>rejected: an error has been thrown, we should handle it.</li>\n</ul>\n<p>A promise have 2 functions: <code>then</code> and <code>catch</code>.\nYou can use <code>then</code> to wait for the result (or handle an error), and <code>catch</code> to\ncatch all possibles errors of one promise or more.</p>\n<p>Let's see how to use promises with an example of the incoming standardized\n<a href=\"https://fetch.spec.whatwg.org\"><code>fetch</code></a> method.</p>\n<pre><code class=\"language-js\">// At this moment, promise is in progress\nconst fetchPromise = fetch('http://putaindecode.io')\n\n// When promise is resolved, you go a value you can work with\nconst parsePromise = fetchPromise.then(fetchResult => {\n  // I can return a new result that can be used as a new promise\n  // Here we call .text() which parse the content of the request and return\n  // promise\n  return fetchResult.text()\n})\n\n// When parsing is done, we can work with the content\nparsePromise.then(textResult => {\n  console.log(`Here is the text result : ${textResult}`)\n})\n\n// If the request encounter an issue, promise might be rejected with an error\nfetchPromise.catch(fetchError => {\n  console.log(`We got an issue during the request`, fetchError)\n})\n\n// If there is an issue during the parsing, we can handle it too\nparsePromise.catch(parseError => {\n  console.log(\"We got an issue during the parsing\", parseError)\n})\n\n// The same can be written like this\nfetch('http://putaindecode.io')\n  .then((fetchResult) => fetchResult.text())\n  .then((textResult) => {\n    console.log(`Here is the text result : ${textResult}`)\n  })\n  .catch((error) => {\n    console.log(`We got an issue during the request or the parsing`, fetchError)\n  })\n\n// Or like this\nfetch('http://putaindecode.io')\n  .then(\n    (fetchResult) => {\n      return fetchResult.text()\n    },\n    (fetchError) => {\n      console.log(`We got an issue during the request`, fetchError)\n    })\n  .then(\n    (textResult) => {\n      console.log(`Here is the text result : ${textResult}`)\n    },\n    (parseError) => {\n      console.log(\"We got an issue during the parsing\", parseError)\n    }\n  )\n</code></pre>\n<h2 id=\"how-do-i-create-my-own-promises\"><a href=\"#how-do-i-create-my-own-promises\"></a>How do I create my own promises?</h2>\n<p>Using a promise is nice, but creating yours is even better. Let's be clear: it's\neasy.</p>\n<pre><code class=\"language-js\">const functionThatReturnAPromise = (success) => {\n  // We will need to use Promise class to use one.\n  // constructor takes 2 arguments:\n  // - resolve, a callback to pass the value you want to send\n  // - reject, a callback to throw an error\n  return new Promise((resolve, reject) => {\n    if (success) {\n      resolve('success')\n    }\n    else {\n      reject('failed')\n    }\n  })\n}\n\n// You can use this promise like this\nfunctionThatReturnAPromise(success)\n  .then(res => console.log(res))\n  .catch(error => console.log(error))\n\n// In our case, the previous example can be also written\nfunctionThatReturnAPromise(success)\n  .then(\n    (res) => console.log(res),\n    (error) => console.log(error)\n  )\n</code></pre>\n<h2 id=\"whats-next\"><a href=\"#whats-next\"></a>What's next?</h2>\n<p>A new way to write asynchronous will land in JavaScript with <code>async</code> and <code>await</code>\nkeywords, but we will need to way another ES year (or two) for it !</p>\n","rawBody":"\nWith ES2015, you can now very easily write asynchronous code thanks to the\npromises.\nThe concept of promises exists is not new in the JavaScript world, but now\nwe got an official feature!\n\n## What's a promise?\n\nIt's a promise of an incoming value, not available yet. It's a promise so it can\nbe fulfilled or not (rejected). If fulfilled, it will give us the the value we\nwere waiting for. If rejected, we will get the error so we can handle it.\n\nThis mechanism allows to avoid the callback hell :\n\n```js\n// With callbacks.\n// Let's say that all those function are doing async tasks (like http or\n// database request, fs read...)\nconst functionWithCallback1 = (callback) => callback('test', undefined)\nconst functionWithCallback2 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback3 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback4 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback5 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback6 = (arg, callback) => callback(arg, undefined)\n\nfunctionWithCallback1((result1, err) => {\n  if (err) {\n    throw err\n  }\n  functionWithCallback2(result1, (result2, err) => {\n    if (err) {\n      throw err\n    }\n    functionWithCallback3(result2, (result3, err) => {\n      if (err) {\n        throw err\n      }\n      functionWithCallback4(result3, (result4, err) => {\n        if (err) {\n          throw err\n        }\n        functionWithCallback5(result4, (result5, err) => {\n          if (err) {\n            throw err\n          }\n          functionWithCallback6(result5, (result6, err) => {\n            if (err) {\n              throw err\n            }\n            console.log(`Example with callbacks: ${result6}`)\n          })\n        })\n      })\n    })\n  })\n})\n\n// Now the same thing with promises\nconst functionWithPromise1 = () => Promise.resolve('test')\nconst functionWithPromise2 = (arg) => Promise.resolve(arg)\nconst functionWithPromise3 = (arg) => Promise.resolve(arg)\nconst functionWithPromise4 = (arg) => Promise.resolve(arg)\nconst functionWithPromise5 = (arg) => Promise.resolve(arg)\nconst functionWithPromise6 = (arg) => Promise.resolve(arg)\n\nfunctionWithPromise1()\n  .then(functionWithPromise2)\n  .then(functionWithPromise3)\n  .then(functionWithPromise4)\n  .then(functionWithPromise5)\n  .then(functionWithPromise6)\n  .then(result => console.log(`Example with promises: ${result}`))\n  .catch(err => {\n    throw err\n  })\n```\n\nAs you can see, example with promises is clear and more concise.\n\n## That's cool. How can I use promises?\n\nA promise can have different status:\n- in progress: value is not ready yet\n- resolved: value is here, we can use it\n- rejected: an error has been thrown, we should handle it.\n\nA promise have 2 functions: `then` and `catch`.\nYou can use `then` to wait for the result (or handle an error), and `catch` to\ncatch all possibles errors of one promise or more.\n\nLet's see how to use promises with an example of the incoming standardized\n[`fetch`](https://fetch.spec.whatwg.org) method.\n\n```js\n// At this moment, promise is in progress\nconst fetchPromise = fetch('http://putaindecode.io')\n\n// When promise is resolved, you go a value you can work with\nconst parsePromise = fetchPromise.then(fetchResult => {\n  // I can return a new result that can be used as a new promise\n  // Here we call .text() which parse the content of the request and return\n  // promise\n  return fetchResult.text()\n})\n\n// When parsing is done, we can work with the content\nparsePromise.then(textResult => {\n  console.log(`Here is the text result : ${textResult}`)\n})\n\n// If the request encounter an issue, promise might be rejected with an error\nfetchPromise.catch(fetchError => {\n  console.log(`We got an issue during the request`, fetchError)\n})\n\n// If there is an issue during the parsing, we can handle it too\nparsePromise.catch(parseError => {\n  console.log(\"We got an issue during the parsing\", parseError)\n})\n\n// The same can be written like this\nfetch('http://putaindecode.io')\n  .then((fetchResult) => fetchResult.text())\n  .then((textResult) => {\n    console.log(`Here is the text result : ${textResult}`)\n  })\n  .catch((error) => {\n    console.log(`We got an issue during the request or the parsing`, fetchError)\n  })\n\n// Or like this\nfetch('http://putaindecode.io')\n  .then(\n    (fetchResult) => {\n      return fetchResult.text()\n    },\n    (fetchError) => {\n      console.log(`We got an issue during the request`, fetchError)\n    })\n  .then(\n    (textResult) => {\n      console.log(`Here is the text result : ${textResult}`)\n    },\n    (parseError) => {\n      console.log(\"We got an issue during the parsing\", parseError)\n    }\n  )\n```\n\n## How do I create my own promises?\n\nUsing a promise is nice, but creating yours is even better. Let's be clear: it's\neasy.\n\n```js\nconst functionThatReturnAPromise = (success) => {\n  // We will need to use Promise class to use one.\n  // constructor takes 2 arguments:\n  // - resolve, a callback to pass the value you want to send\n  // - reject, a callback to throw an error\n  return new Promise((resolve, reject) => {\n    if (success) {\n      resolve('success')\n    }\n    else {\n      reject('failed')\n    }\n  })\n}\n\n// You can use this promise like this\nfunctionThatReturnAPromise(success)\n  .then(res => console.log(res))\n  .catch(error => console.log(error))\n\n// In our case, the previous example can be also written\nfunctionThatReturnAPromise(success)\n  .then(\n    (res) => console.log(res),\n    (error) => console.log(error)\n  )\n```\n\n## What's next?\n\nA new way to write asynchronous will land in JavaScript with `async` and `await`\nkeywords, but we will need to way another ES year (or two) for it !\n","raw":"---\ndate: \"2015-12-06\"\ntitle: \"ES6, ES2015 : Promises\"\ntags:\n  - JavaScript\n  - ES6\n  - ES2015\nauthors:\n  - Uhsac\ntranslators:\n  - MoOx\n---\n\nWith ES2015, you can now very easily write asynchronous code thanks to the\npromises.\nThe concept of promises exists is not new in the JavaScript world, but now\nwe got an official feature!\n\n## What's a promise?\n\nIt's a promise of an incoming value, not available yet. It's a promise so it can\nbe fulfilled or not (rejected). If fulfilled, it will give us the the value we\nwere waiting for. If rejected, we will get the error so we can handle it.\n\nThis mechanism allows to avoid the callback hell :\n\n```js\n// With callbacks.\n// Let's say that all those function are doing async tasks (like http or\n// database request, fs read...)\nconst functionWithCallback1 = (callback) => callback('test', undefined)\nconst functionWithCallback2 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback3 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback4 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback5 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback6 = (arg, callback) => callback(arg, undefined)\n\nfunctionWithCallback1((result1, err) => {\n  if (err) {\n    throw err\n  }\n  functionWithCallback2(result1, (result2, err) => {\n    if (err) {\n      throw err\n    }\n    functionWithCallback3(result2, (result3, err) => {\n      if (err) {\n        throw err\n      }\n      functionWithCallback4(result3, (result4, err) => {\n        if (err) {\n          throw err\n        }\n        functionWithCallback5(result4, (result5, err) => {\n          if (err) {\n            throw err\n          }\n          functionWithCallback6(result5, (result6, err) => {\n            if (err) {\n              throw err\n            }\n            console.log(`Example with callbacks: ${result6}`)\n          })\n        })\n      })\n    })\n  })\n})\n\n// Now the same thing with promises\nconst functionWithPromise1 = () => Promise.resolve('test')\nconst functionWithPromise2 = (arg) => Promise.resolve(arg)\nconst functionWithPromise3 = (arg) => Promise.resolve(arg)\nconst functionWithPromise4 = (arg) => Promise.resolve(arg)\nconst functionWithPromise5 = (arg) => Promise.resolve(arg)\nconst functionWithPromise6 = (arg) => Promise.resolve(arg)\n\nfunctionWithPromise1()\n  .then(functionWithPromise2)\n  .then(functionWithPromise3)\n  .then(functionWithPromise4)\n  .then(functionWithPromise5)\n  .then(functionWithPromise6)\n  .then(result => console.log(`Example with promises: ${result}`))\n  .catch(err => {\n    throw err\n  })\n```\n\nAs you can see, example with promises is clear and more concise.\n\n## That's cool. How can I use promises?\n\nA promise can have different status:\n- in progress: value is not ready yet\n- resolved: value is here, we can use it\n- rejected: an error has been thrown, we should handle it.\n\nA promise have 2 functions: `then` and `catch`.\nYou can use `then` to wait for the result (or handle an error), and `catch` to\ncatch all possibles errors of one promise or more.\n\nLet's see how to use promises with an example of the incoming standardized\n[`fetch`](https://fetch.spec.whatwg.org) method.\n\n```js\n// At this moment, promise is in progress\nconst fetchPromise = fetch('http://putaindecode.io')\n\n// When promise is resolved, you go a value you can work with\nconst parsePromise = fetchPromise.then(fetchResult => {\n  // I can return a new result that can be used as a new promise\n  // Here we call .text() which parse the content of the request and return\n  // promise\n  return fetchResult.text()\n})\n\n// When parsing is done, we can work with the content\nparsePromise.then(textResult => {\n  console.log(`Here is the text result : ${textResult}`)\n})\n\n// If the request encounter an issue, promise might be rejected with an error\nfetchPromise.catch(fetchError => {\n  console.log(`We got an issue during the request`, fetchError)\n})\n\n// If there is an issue during the parsing, we can handle it too\nparsePromise.catch(parseError => {\n  console.log(\"We got an issue during the parsing\", parseError)\n})\n\n// The same can be written like this\nfetch('http://putaindecode.io')\n  .then((fetchResult) => fetchResult.text())\n  .then((textResult) => {\n    console.log(`Here is the text result : ${textResult}`)\n  })\n  .catch((error) => {\n    console.log(`We got an issue during the request or the parsing`, fetchError)\n  })\n\n// Or like this\nfetch('http://putaindecode.io')\n  .then(\n    (fetchResult) => {\n      return fetchResult.text()\n    },\n    (fetchError) => {\n      console.log(`We got an issue during the request`, fetchError)\n    })\n  .then(\n    (textResult) => {\n      console.log(`Here is the text result : ${textResult}`)\n    },\n    (parseError) => {\n      console.log(\"We got an issue during the parsing\", parseError)\n    }\n  )\n```\n\n## How do I create my own promises?\n\nUsing a promise is nice, but creating yours is even better. Let's be clear: it's\neasy.\n\n```js\nconst functionThatReturnAPromise = (success) => {\n  // We will need to use Promise class to use one.\n  // constructor takes 2 arguments:\n  // - resolve, a callback to pass the value you want to send\n  // - reject, a callback to throw an error\n  return new Promise((resolve, reject) => {\n    if (success) {\n      resolve('success')\n    }\n    else {\n      reject('failed')\n    }\n  })\n}\n\n// You can use this promise like this\nfunctionThatReturnAPromise(success)\n  .then(res => console.log(res))\n  .catch(error => console.log(error))\n\n// In our case, the previous example can be also written\nfunctionThatReturnAPromise(success)\n  .then(\n    (res) => console.log(res),\n    (error) => console.log(error)\n  )\n```\n\n## What's next?\n\nA new way to write asynchronous will land in JavaScript with `async` and `await`\nkeywords, but we will need to way another ES year (or two) for it !\n","__filename":"en/articles/js/es2015/promises.md","__url":"/en/articles/js/es2015/promises/","__resourceUrl":"/en/articles/js/es2015/promises/index.html","__dataUrl":"/en/articles/js/es2015/promises/index.html.5c836a89b10e492d40869fd7ee1e419b.json"}