{"head":{"layout":"Post","comments":true,"date":"2015-12-10","title":"ES6, ES2015 : iterators and generators","tags":["JavaScript","ES6","ES2015"],"authors":["naholyr"],"translators":["MoOx"],"description":"ES2015 brings a lot of syntax sugar but not a lot of new real features. Generators are a new feature to generate iterators that follow the…"},"body":"<p>ES2015 brings a lot of syntax sugar but not a lot of new real features.\nGenerators are a new feature to generate iterators that follow the\n<a href=\"/en/articles/js/es2015/iterators/\">iterator protocol</a>.\nThey allow to take control of the execution of a function from the outside.</p>\n<h2 id=\"idle-function\"><a href=\"#idle-function\"></a>Idle function</h2>\n<p>A function followed by an asterisk (<code>function*</code>) is never executed directly\nand instead calling it will return an iterator.\nA generator is able to pause itself (and will do that by default).\nIt's also capable of continue where it was paused: the iterator returned is an\nobject that contains a <code>next</code> method which allows (when you call it) to\ncontinue the execution of the generator where it was paused.</p>\n<pre><code class=\"language-js\">function * idleFunction () {\n  console.log('World')\n}\n\nconst iterator = idleFunction()\n// The execution is paused, and is waiting to be continued\nconsole.log('Hello')\niterator.next() // The execution will now continue and will log \"World\"\n</code></pre>\n<p>Note that this is not <strong>blocking</strong> code: the function is paused, the execution\ncan continue later, but meanwhile, the <em>event-loop</em> is still running.</p>\n<h2 id=\"emitting-new-values-with-yield\"><a href=\"#emitting-new-values-with-yield\"></a>Emitting new values with <code>yield</code></h2>\n<p>Following the <a href=\"/en/articles/js/es2015/iterators/\">iterator protocol</a>, the\n<code>next()</code> method will returns an object with 2 properties :</p>\n<ul>\n<li><code>done</code> is equal to <code>true</code> when generator has finished its job exécution</li>\n<li><code>value</code> is the value emitted by the generator when it become idle</li>\n</ul>\n<p>How to emit a value ? The keyword <code>yield</code> is made for this:\nit will returns a value and idle the execution of the function.\nThe thing is: you are going to use yield multiple times in the same function.\nOtherwise a generator does not make sense, and a simple function with <code>return</code>\nis enough.</p>\n<pre><code class=\"language-js\">function * numbers () {\n  yield 1\n  yield 2\n}\n\nconst iterator = numbers()\niterator.next() // { value: 1, done: false }\niterator.next() // { value: 2, done: false }\niterator.next() // { value: undefined, done: true }\n</code></pre>\n<p>Note: if our generator <code>return</code>s a value, it will be affected to the <code>value</code>\nof the last iteration.</p>\n<h3 id=\"use-case-infinite-lists\"><a href=\"#use-case-infinite-lists\"></a><em>Use case</em> : infinite lists</h3>\n<p>At this stage, the first interesting use case is to handle an infinite list.\nWe can loop on a list that do not have a precise length.\nHere is an example with the Fibonacci sequence to get all results lower than\n100 :</p>\n<pre><code class=\"language-js\">function * fibo () {\n  let [a, b] = [1, 1]\n  while (true) { // Who can stop me?\n    [a, b] = [b, a + b]\n    yield a\n  }\n}\n\nconst iterator = fibo()\nfor (let n of iterator) {\n  if (n >= 100) {\n    break // *I* can stop you\n  }\n  console.log(n)\n}\n// 1 2 3 5 8 13 21 34 55 89\n</code></pre>\n<p>Note : The <code>for … of</code> will be explained in another article.</p>\n<h2 id=\"sending-value-to-the-generator\"><a href=\"#sending-value-to-the-generator\"></a>Sending value to the generator</h2>\n<p>We have seen that <code>yield</code> allows to emit a value from the generator.\nThe opposite is possible too : <code>next</code> accepts a value that will be returned by\n<code>yield</code> :</p>\n<pre><code class=\"language-js\">function * math () {\n  // the first next() will \"start\" the generator\n  const x = yield // the first value will be undefined\n  // x = the argument of the other next() call\n  const y = yield x + 1 // value of the second iteration : x + 1\n  // y = third call of next()\n  yield y // value of the last iteration : y\n  // the fourth call and the others will return { value: undefined, done: true }\n}\n\nconst iterator = math()\niterator.next(42) // { value: undefined, done: false }\n// Passer un paramètre au premier appel à next() n'est pas utile : cette valeur\n// n'est pas accessible dans le générateur car aucun \"yield\" correspondant\n\niterator.next(33) // { value: 34, done: false }, x = 33 dans le générateur\niterator.next(27) // { value: 27, done: false }, y = 27 dans le générateur\niterator.next() // { value: undefined, done: true }\n</code></pre>\n<p>This might sound not really useful, but keep in mind that you can send any type\nof data to <code>next()</code> : a function, an object, another iterator...\nPossiblities are limitless ! Let's take a look to an example using promises.</p>\n<h3 id=\"use-case-co-routines\"><a href=\"#use-case-co-routines\"></a><em>Use case</em> : co-routines</h3>\n<p>The code of the generator itself cannot be async: call to <code>yield</code> follow each\nothers synchronously.\nThe main controller can still be free to call <code>next()</code> when it wants to.</p>\n<p>So we have functions that we can play and pause whenever we want.\nWhat if our generator emitted a promise? In order to tell when it's time to\ncontinue.\nWhat if the controller, when it knows it got a promise wait for it to be\nresolved in order to send back the value to the generator?\nThis way, the generator will be able to run synchronous code in an non blocking\nway when handling async operations :</p>\n<pre><code class=\"language-js\">execAsync(function * () {\n  console.log(\"Ajax request…\")\n  var rows = yield fetch(\"http://my.api/get\")\n  console.log(\"Work…\")\n  console.log(\"Save…\")\n  yield fetch(\"http://my.api/post\")\n  console.log(\"OK.\")\n}) // Ajax request… Work… Save… OK.\n</code></pre>\n<p>How cool is that? This is clearly the most interesting use case for us and is\nactually pretty simple :</p>\n<pre><code class=\"language-js\">function execAsync (promiseGenerator) {\n  const iter = promiseGenerator() // pause…\n\n  function loop (iteration) {\n    if (iteration.done) { // That's the part to detect the last return\n      return iteration.value\n    }\n\n    // this is a generator of promise, we we wait for the resolution\n    return iteration.value.then(result => {\n      // promise is resolved so we can send back the value to the generator\n      const nextIteration = iter.next(result) // this value is returned by the\n      // same \"yield\" which emitted the promise, how convenient is that?\n\n      // NEXXXTTTT\n      return next(nextIteration)\n    })\n  }\n\n  const promiseIteration = iter.next()\n  // we continue the execution until the next \"yield\"\n  // the generator will be paused again until the next call to \"iter.next\"\n\n  // We run the first iteration it and return it\n  return loop(promiseIteration)\n}\n</code></pre>\n<h2 id=\"more-more-more\"><a href=\"#more-more-more\"></a>More! more! more!</h2>\n<h3 id=\"error-handling\"><a href=\"#error-handling\"></a>Error handling</h3>\n<p>Errors, like everything, can be emitted in both directions.\nThe generator can <code>throw</code> (the code is synchronous) :</p>\n<pre><code class=\"language-js\">function * fail () {\n  yield 1\n  throw new Error('oops')\n  yield 2\n}\n\nconst iterator = fail()\niterator.next() // { value: 1, done: false }\ntry {\n  iterator.next() // throws\n} catch (e) {\n  e // Error('oops')\n}\n</code></pre>\n<p>The controller can also emit an error inside with the <code>throw</code> method of the\niterator :</p>\n<pre><code class=\"language-js\">function * fail () {\n  try {\n    yield 1\n  } catch (e) {\n    console.error(e)\n  }\n  yield 2\n}\n\nconst iterator = fail()\niterator.next() // { value: 1, done: false }\niterator.throw(new Error(\"nope\")) // \"[Error: nope]\"\niterator.next() // { value: 2, done: false }\niterator.next() // { value: undefined, done: true }\n</code></pre>\n<p>Note: you need to keep in mind that the first <code>next</code> is used to unlock\nthe execution of the generator, until the first <code>yield</code>, evaluate the emitted\nexpression, and send it in the <code>next()</code>, and pause the function.\nThat's the second <code>yield</code> that will continue <strong>from the <code>yield 1</code></strong>.\nThis is a part not really intuitive that can be hard to understand.</p>\n<h3 id=\"delegation\"><a href=\"#delegation\"></a>Delegation</h3>\n<p>The <code>yield*</code> operator allow to emit value from another iterator :</p>\n<pre><code class=\"language-js\">function * oneToThree () {\n  yield 1\n  yield 2\n  yield 3\n}\n\nfunction * zeroToFour () {\n  yield 0\n  yield * oneToThree()\n  yield 4\n}\n</code></pre>\n<p>That works with all <a href=\"/en/articles/js/es2015/iterators/\"><em>iterables</em></a> :\nfor example <code>yield * [1, 2, 3]</code> is valid.</p>\n<h3 id=\"anticipated-return\"><a href=\"#anticipated-return\"></a>Anticipated return</h3>\n<p>It's possible to end an operation of a generator from the controller using the\n<code>return</code> method of the iterator.\nEverything will happen like if the generator was ending immediately with the\nreturned value.</p>\n<pre><code class=\"language-js\">function * numbers () {\n  yield 1\n  yield 2\n  yield 3\n}\n\nconst iterator = numbers()\niterator.next() // { value: 1, done: false }\niterator.return(4) // { value: 4, done: true } → yield 2 and yield 3 are skipped\niterator.next() // { value: undefined, done: true }\n</code></pre>\n<h2 id=\"conclusion\"><a href=\"#conclusion\"></a>Conclusion</h2>\n<p>Take a look to the\n<a href=\"https://kangax.github.io/compat-table/es6/#test-generators\">compatibility table</a>.</p>\n<p>Generators bring us a new bundle of feature that allow us to inverse\nresponsibility : the code that calling the generator can take over the way the\ncalled function will be executed.\nThey represent a new concept that will probably really change the way we will\ncode in the incoming months/years :\nasync function, observables... take their roots in generators.\nUnderstanding generators will helps you to work with those other new features.</p>\n","rawBody":"\nES2015 brings a lot of syntax sugar but not a lot of new real features.\nGenerators are a new feature to generate iterators that follow the\n[iterator protocol](/en/articles/js/es2015/iterators/).\nThey allow to take control of the execution of a function from the outside.\n\n## Idle function\n\nA function followed by an asterisk (``function*``) is never executed directly\nand instead calling it will return an iterator.\nA generator is able to pause itself (and will do that by default).\nIt's also capable of continue where it was paused: the iterator returned is an\nobject that contains a ``next`` method which allows (when you call it) to\ncontinue the execution of the generator where it was paused.\n\n```js\nfunction * idleFunction () {\n  console.log('World')\n}\n\nconst iterator = idleFunction()\n// The execution is paused, and is waiting to be continued\nconsole.log('Hello')\niterator.next() // The execution will now continue and will log \"World\"\n```\n\nNote that this is not **blocking** code: the function is paused, the execution\ncan continue later, but meanwhile, the *event-loop* is still running.\n\n## Emitting new values with ``yield``\n\nFollowing the [iterator protocol](/en/articles/js/es2015/iterators/), the\n``next()`` method will returns an object with 2 properties :\n\n* ``done`` is equal to ``true`` when generator has finished its job exécution\n* ``value`` is the value emitted by the generator when it become idle\n\nHow to emit a value ? The keyword ``yield`` is made for this:\nit will returns a value and idle the execution of the function.\nThe thing is: you are going to use yield multiple times in the same function.\nOtherwise a generator does not make sense, and a simple function with ``return``\nis enough.\n\n```js\nfunction * numbers () {\n  yield 1\n  yield 2\n}\n\nconst iterator = numbers()\niterator.next() // { value: 1, done: false }\niterator.next() // { value: 2, done: false }\niterator.next() // { value: undefined, done: true }\n```\n\nNote: if our generator ``return``s a value, it will be affected to the ``value``\nof the last iteration.\n\n### _Use case_ : infinite lists\n\nAt this stage, the first interesting use case is to handle an infinite list.\nWe can loop on a list that do not have a precise length.\nHere is an example with the Fibonacci sequence to get all results lower than\n100 :\n\n```js\nfunction * fibo () {\n  let [a, b] = [1, 1]\n  while (true) { // Who can stop me?\n    [a, b] = [b, a + b]\n    yield a\n  }\n}\n\nconst iterator = fibo()\nfor (let n of iterator) {\n  if (n >= 100) {\n    break // *I* can stop you\n  }\n  console.log(n)\n}\n// 1 2 3 5 8 13 21 34 55 89\n```\n\nNote : The ``for … of`` will be explained in another article.\n\n## Sending value to the generator\n\nWe have seen that ``yield`` allows to emit a value from the generator.\nThe opposite is possible too : ``next`` accepts a value that will be returned by\n``yield`` :\n\n```js\nfunction * math () {\n  // the first next() will \"start\" the generator\n  const x = yield // the first value will be undefined\n  // x = the argument of the other next() call\n  const y = yield x + 1 // value of the second iteration : x + 1\n  // y = third call of next()\n  yield y // value of the last iteration : y\n  // the fourth call and the others will return { value: undefined, done: true }\n}\n\nconst iterator = math()\niterator.next(42) // { value: undefined, done: false }\n// Passer un paramètre au premier appel à next() n'est pas utile : cette valeur\n// n'est pas accessible dans le générateur car aucun \"yield\" correspondant\n\niterator.next(33) // { value: 34, done: false }, x = 33 dans le générateur\niterator.next(27) // { value: 27, done: false }, y = 27 dans le générateur\niterator.next() // { value: undefined, done: true }\n```\n\nThis might sound not really useful, but keep in mind that you can send any type\nof data to ``next()`` : a function, an object, another iterator...\nPossiblities are limitless ! Let's take a look to an example using promises.\n\n### _Use case_ : co-routines\n\nThe code of the generator itself cannot be async: call to ``yield`` follow each\nothers synchronously.\nThe main controller can still be free to call ``next()`` when it wants to.\n\nSo we have functions that we can play and pause whenever we want.\nWhat if our generator emitted a promise? In order to tell when it's time to\ncontinue.\nWhat if the controller, when it knows it got a promise wait for it to be\nresolved in order to send back the value to the generator?\nThis way, the generator will be able to run synchronous code in an non blocking\nway when handling async operations :\n\n```js\nexecAsync(function * () {\n  console.log(\"Ajax request…\")\n  var rows = yield fetch(\"http://my.api/get\")\n  console.log(\"Work…\")\n  console.log(\"Save…\")\n  yield fetch(\"http://my.api/post\")\n  console.log(\"OK.\")\n}) // Ajax request… Work… Save… OK.\n```\n\nHow cool is that? This is clearly the most interesting use case for us and is\nactually pretty simple :\n\n```js\nfunction execAsync (promiseGenerator) {\n  const iter = promiseGenerator() // pause…\n\n  function loop (iteration) {\n    if (iteration.done) { // That's the part to detect the last return\n      return iteration.value\n    }\n\n    // this is a generator of promise, we we wait for the resolution\n    return iteration.value.then(result => {\n      // promise is resolved so we can send back the value to the generator\n      const nextIteration = iter.next(result) // this value is returned by the\n      // same \"yield\" which emitted the promise, how convenient is that?\n\n      // NEXXXTTTT\n      return next(nextIteration)\n    })\n  }\n\n  const promiseIteration = iter.next()\n  // we continue the execution until the next \"yield\"\n  // the generator will be paused again until the next call to \"iter.next\"\n\n  // We run the first iteration it and return it\n  return loop(promiseIteration)\n}\n```\n\n## More! more! more!\n\n### Error handling\n\nErrors, like everything, can be emitted in both directions.\nThe generator can ``throw`` (the code is synchronous) :\n\n```js\nfunction * fail () {\n  yield 1\n  throw new Error('oops')\n  yield 2\n}\n\nconst iterator = fail()\niterator.next() // { value: 1, done: false }\ntry {\n  iterator.next() // throws\n} catch (e) {\n  e // Error('oops')\n}\n```\n\nThe controller can also emit an error inside with the ``throw`` method of the\niterator :\n\n```js\nfunction * fail () {\n  try {\n    yield 1\n  } catch (e) {\n    console.error(e)\n  }\n  yield 2\n}\n\nconst iterator = fail()\niterator.next() // { value: 1, done: false }\niterator.throw(new Error(\"nope\")) // \"[Error: nope]\"\niterator.next() // { value: 2, done: false }\niterator.next() // { value: undefined, done: true }\n```\n\nNote: you need to keep in mind that the first ``next`` is used to unlock\nthe execution of the generator, until the first ``yield``, evaluate the emitted\nexpression, and send it in the ``next()``, and pause the function.\nThat's the second ``yield`` that will continue **from the ``yield 1``**.\nThis is a part not really intuitive that can be hard to understand.\n\n### Delegation\n\nThe ``yield*`` operator allow to emit value from another iterator :\n\n```js\nfunction * oneToThree () {\n  yield 1\n  yield 2\n  yield 3\n}\n\nfunction * zeroToFour () {\n  yield 0\n  yield * oneToThree()\n  yield 4\n}\n```\n\nThat works with all [*iterables*](/en/articles/js/es2015/iterators/) :\nfor example ``yield * [1, 2, 3]`` is valid.\n\n### Anticipated return\n\nIt's possible to end an operation of a generator from the controller using the\n``return`` method of the iterator.\nEverything will happen like if the generator was ending immediately with the\nreturned value.\n\n```js\nfunction * numbers () {\n  yield 1\n  yield 2\n  yield 3\n}\n\nconst iterator = numbers()\niterator.next() // { value: 1, done: false }\niterator.return(4) // { value: 4, done: true } → yield 2 and yield 3 are skipped\niterator.next() // { value: undefined, done: true }\n```\n\n## Conclusion\n\nTake a look to the\n[compatibility table](https://kangax.github.io/compat-table/es6/#test-generators).\n\nGenerators bring us a new bundle of feature that allow us to inverse\nresponsibility : the code that calling the generator can take over the way the\ncalled function will be executed.\nThey represent a new concept that will probably really change the way we will\ncode in the incoming months/years :\nasync function, observables... take their roots in generators.\nUnderstanding generators will helps you to work with those other new features.\n","raw":"---\ndate: \"2015-12-10\"\ntitle: \"ES6, ES2015 : iterators and generators\"\ntags:\n  - JavaScript\n  - ES6\n  - ES2015\nauthors:\n  - naholyr\ntranslators:\n  - MoOx\n---\n\nES2015 brings a lot of syntax sugar but not a lot of new real features.\nGenerators are a new feature to generate iterators that follow the\n[iterator protocol](/en/articles/js/es2015/iterators/).\nThey allow to take control of the execution of a function from the outside.\n\n## Idle function\n\nA function followed by an asterisk (``function*``) is never executed directly\nand instead calling it will return an iterator.\nA generator is able to pause itself (and will do that by default).\nIt's also capable of continue where it was paused: the iterator returned is an\nobject that contains a ``next`` method which allows (when you call it) to\ncontinue the execution of the generator where it was paused.\n\n```js\nfunction * idleFunction () {\n  console.log('World')\n}\n\nconst iterator = idleFunction()\n// The execution is paused, and is waiting to be continued\nconsole.log('Hello')\niterator.next() // The execution will now continue and will log \"World\"\n```\n\nNote that this is not **blocking** code: the function is paused, the execution\ncan continue later, but meanwhile, the *event-loop* is still running.\n\n## Emitting new values with ``yield``\n\nFollowing the [iterator protocol](/en/articles/js/es2015/iterators/), the\n``next()`` method will returns an object with 2 properties :\n\n* ``done`` is equal to ``true`` when generator has finished its job exécution\n* ``value`` is the value emitted by the generator when it become idle\n\nHow to emit a value ? The keyword ``yield`` is made for this:\nit will returns a value and idle the execution of the function.\nThe thing is: you are going to use yield multiple times in the same function.\nOtherwise a generator does not make sense, and a simple function with ``return``\nis enough.\n\n```js\nfunction * numbers () {\n  yield 1\n  yield 2\n}\n\nconst iterator = numbers()\niterator.next() // { value: 1, done: false }\niterator.next() // { value: 2, done: false }\niterator.next() // { value: undefined, done: true }\n```\n\nNote: if our generator ``return``s a value, it will be affected to the ``value``\nof the last iteration.\n\n### _Use case_ : infinite lists\n\nAt this stage, the first interesting use case is to handle an infinite list.\nWe can loop on a list that do not have a precise length.\nHere is an example with the Fibonacci sequence to get all results lower than\n100 :\n\n```js\nfunction * fibo () {\n  let [a, b] = [1, 1]\n  while (true) { // Who can stop me?\n    [a, b] = [b, a + b]\n    yield a\n  }\n}\n\nconst iterator = fibo()\nfor (let n of iterator) {\n  if (n >= 100) {\n    break // *I* can stop you\n  }\n  console.log(n)\n}\n// 1 2 3 5 8 13 21 34 55 89\n```\n\nNote : The ``for … of`` will be explained in another article.\n\n## Sending value to the generator\n\nWe have seen that ``yield`` allows to emit a value from the generator.\nThe opposite is possible too : ``next`` accepts a value that will be returned by\n``yield`` :\n\n```js\nfunction * math () {\n  // the first next() will \"start\" the generator\n  const x = yield // the first value will be undefined\n  // x = the argument of the other next() call\n  const y = yield x + 1 // value of the second iteration : x + 1\n  // y = third call of next()\n  yield y // value of the last iteration : y\n  // the fourth call and the others will return { value: undefined, done: true }\n}\n\nconst iterator = math()\niterator.next(42) // { value: undefined, done: false }\n// Passer un paramètre au premier appel à next() n'est pas utile : cette valeur\n// n'est pas accessible dans le générateur car aucun \"yield\" correspondant\n\niterator.next(33) // { value: 34, done: false }, x = 33 dans le générateur\niterator.next(27) // { value: 27, done: false }, y = 27 dans le générateur\niterator.next() // { value: undefined, done: true }\n```\n\nThis might sound not really useful, but keep in mind that you can send any type\nof data to ``next()`` : a function, an object, another iterator...\nPossiblities are limitless ! Let's take a look to an example using promises.\n\n### _Use case_ : co-routines\n\nThe code of the generator itself cannot be async: call to ``yield`` follow each\nothers synchronously.\nThe main controller can still be free to call ``next()`` when it wants to.\n\nSo we have functions that we can play and pause whenever we want.\nWhat if our generator emitted a promise? In order to tell when it's time to\ncontinue.\nWhat if the controller, when it knows it got a promise wait for it to be\nresolved in order to send back the value to the generator?\nThis way, the generator will be able to run synchronous code in an non blocking\nway when handling async operations :\n\n```js\nexecAsync(function * () {\n  console.log(\"Ajax request…\")\n  var rows = yield fetch(\"http://my.api/get\")\n  console.log(\"Work…\")\n  console.log(\"Save…\")\n  yield fetch(\"http://my.api/post\")\n  console.log(\"OK.\")\n}) // Ajax request… Work… Save… OK.\n```\n\nHow cool is that? This is clearly the most interesting use case for us and is\nactually pretty simple :\n\n```js\nfunction execAsync (promiseGenerator) {\n  const iter = promiseGenerator() // pause…\n\n  function loop (iteration) {\n    if (iteration.done) { // That's the part to detect the last return\n      return iteration.value\n    }\n\n    // this is a generator of promise, we we wait for the resolution\n    return iteration.value.then(result => {\n      // promise is resolved so we can send back the value to the generator\n      const nextIteration = iter.next(result) // this value is returned by the\n      // same \"yield\" which emitted the promise, how convenient is that?\n\n      // NEXXXTTTT\n      return next(nextIteration)\n    })\n  }\n\n  const promiseIteration = iter.next()\n  // we continue the execution until the next \"yield\"\n  // the generator will be paused again until the next call to \"iter.next\"\n\n  // We run the first iteration it and return it\n  return loop(promiseIteration)\n}\n```\n\n## More! more! more!\n\n### Error handling\n\nErrors, like everything, can be emitted in both directions.\nThe generator can ``throw`` (the code is synchronous) :\n\n```js\nfunction * fail () {\n  yield 1\n  throw new Error('oops')\n  yield 2\n}\n\nconst iterator = fail()\niterator.next() // { value: 1, done: false }\ntry {\n  iterator.next() // throws\n} catch (e) {\n  e // Error('oops')\n}\n```\n\nThe controller can also emit an error inside with the ``throw`` method of the\niterator :\n\n```js\nfunction * fail () {\n  try {\n    yield 1\n  } catch (e) {\n    console.error(e)\n  }\n  yield 2\n}\n\nconst iterator = fail()\niterator.next() // { value: 1, done: false }\niterator.throw(new Error(\"nope\")) // \"[Error: nope]\"\niterator.next() // { value: 2, done: false }\niterator.next() // { value: undefined, done: true }\n```\n\nNote: you need to keep in mind that the first ``next`` is used to unlock\nthe execution of the generator, until the first ``yield``, evaluate the emitted\nexpression, and send it in the ``next()``, and pause the function.\nThat's the second ``yield`` that will continue **from the ``yield 1``**.\nThis is a part not really intuitive that can be hard to understand.\n\n### Delegation\n\nThe ``yield*`` operator allow to emit value from another iterator :\n\n```js\nfunction * oneToThree () {\n  yield 1\n  yield 2\n  yield 3\n}\n\nfunction * zeroToFour () {\n  yield 0\n  yield * oneToThree()\n  yield 4\n}\n```\n\nThat works with all [*iterables*](/en/articles/js/es2015/iterators/) :\nfor example ``yield * [1, 2, 3]`` is valid.\n\n### Anticipated return\n\nIt's possible to end an operation of a generator from the controller using the\n``return`` method of the iterator.\nEverything will happen like if the generator was ending immediately with the\nreturned value.\n\n```js\nfunction * numbers () {\n  yield 1\n  yield 2\n  yield 3\n}\n\nconst iterator = numbers()\niterator.next() // { value: 1, done: false }\niterator.return(4) // { value: 4, done: true } → yield 2 and yield 3 are skipped\niterator.next() // { value: undefined, done: true }\n```\n\n## Conclusion\n\nTake a look to the\n[compatibility table](https://kangax.github.io/compat-table/es6/#test-generators).\n\nGenerators bring us a new bundle of feature that allow us to inverse\nresponsibility : the code that calling the generator can take over the way the\ncalled function will be executed.\nThey represent a new concept that will probably really change the way we will\ncode in the incoming months/years :\nasync function, observables... take their roots in generators.\nUnderstanding generators will helps you to work with those other new features.\n","__filename":"en/articles/js/es2015/generators.md","__url":"/en/articles/js/es2015/generators/","__resourceUrl":"/en/articles/js/es2015/generators/index.html","__dataUrl":"/en/articles/js/es2015/generators/index.html.590b0f721cefa23582a550be6076d3a8.json"}