{"head":{"layout":"Post","comments":true,"date":"2015-12-03","title":"ES6, ES2015: default values for arguments","tags":["javascript","ES6","ES2015"],"authors":["naholyr"],"translators":["MoOx"],"description":"Tired of typing if (typeof x === 'undefined') x = defaultValue? Again, ES6 will brings us a elegant solution. Default values The…"},"body":"<p>Tired of typing <code>if (typeof x === 'undefined') x = defaultValue</code>? Again, ES6\nwill brings us a elegant solution.</p>\n<h1 id=\"default-values\"><a href=\"#default-values\"></a>Default values</h1>\n<p>The <code>=</code> operator can now help to define a default value to a parameter.</p>\n<h2 id=\"function-parameters\"><a href=\"#function-parameters\"></a>Function parameters</h2>\n<p>You can now specify a default value for a parameter of a function.\nThis value will be used if the parameter is not defined, or explicitly set to\n<em>undefined</em>.</p>\n<pre><code class=\"language-js\">function incr (value, step = 1) {\n  return value + step\n}\n\nincr(41) // 42\nincr(41, undefined) // 42\nincr(33, 9) // 42\n</code></pre>\n<h3 id=\"dynamic-default-values\"><a href=\"#dynamic-default-values\"></a>Dynamic default values</h3>\n<p>We can specify an expression as a default value.\nThis expression will be evalued <strong>during the function call</strong>, not during the\nfunction declaration.</p>\n<pre><code class=\"language-js\">let defaultWho = 'world!'\nfunction hello (who = defaultWho.toUpperCase()) {\n  return 'Hello ' + who\n}\n\nhello() // 'Hello WORLD!'\ndefaultWho = 'Anyone?'\nhello() // 'Hello ANYONE?'\n</code></pre>\n<h3 id=\"reusing-previous-parameters\"><a href=\"#reusing-previous-parameters\"></a>Reusing previous parameters</h3>\n<p>In the default value expression, you can reuse <strong>previous</strong> function parameters:</p>\n<pre><code class=\"language-js\">function foo (x = 1, y = x + 1) {\n  return x + y\n}\n\nfunction bar (x = y + 1, y = 1) {\n  return x + y\n}\n\nfoo() // 1 + (1 + 1) → 3\nbar() // (undefined + 1) + 1 → NaN\n</code></pre>\n<h3 id=\"particular-case-tdz-temporal-dead-zone\"><a href=\"#particular-case-tdz-temporal-dead-zone\"></a>Particular case: TDZ (Temporal Dead Zone)</h3>\n<p>A temporal dead zone is an area of your program where a variable exists, but is\nnot available yet while it didn't get its value.</p>\n<p>The following example is obviously invalid:</p>\n<pre><code class=\"language-js\">function foo (x = x) { // throws ReferenceError?\n}\n</code></pre>\n<p>In fact, during the call of the function, <code>x</code> has not been defined yet,\nso it cannot be used as a default value.\nThis example should trigger an\n<a href=\"http://dmitrysoshnikov.com/ecmascript/es6-notes-default-values-of-parameters/#tdz-temporal-dead-zone-for-parameters\">error</a></p>\n<p>However, scope rules will make this example invalid:</p>\n<pre><code class=\"language-js\">const x = 1\nfunction foo (x = x) { // 'x' used here is the parameter itself\n}\n</code></pre>\n<p>After the evaluation of the default values, we are in the scope of the function\nand in this scope, <code>x</code> corresponds to the parameter (not defined yet) and not\nthe value defined above.</p>\n<p><strong>ProTip: do not reuse a variable name 3 times</strong>\n(that might helps to read and understand your code).</p>\n<h2 id=\"destructuring\"><a href=\"#destructuring\"></a>Destructuring</h2>\n<p>Like for the function arguments, assignments using\n<a href=\"/en/articles/js/es2015/destructuring/\">destructuring</a>\ncan have a default value.</p>\n<pre><code class=\"language-js\">const obj = {z: 42} \nconst { x = 1, y = x + 1, z, w } = obj\nw // undefined\nx // 1\ny // 2\nz // 42\n</code></pre>\n<p>As a reminder, the assignation in the previous example would have been written\nthis way using ES5:</p>\n<pre><code class=\"language-js\">var x = (obj.x === undefined) ? 1 : obj.x \nvar y = (obj.y === undefined) ? x + 1 : obj.y \nvar z = obj.z\nvar w = obj.w\n</code></pre>\n<h1 id=\"enjoy\"><a href=\"#enjoy\"></a>Enjoy!</h1>\n<p>There is no more reasons <em>a priori</em> to see an <code>undefined</code> in an ES6 codebase.</p>\n<p>About the compatibility (at the time of the writing): only Firefox ≥ 43\nsupport this feature (and just for function...).\nSo you will need <a href=\"http://babeljs.io\">Babel</a> or Traceur to be able to use it.</p>\n","rawBody":"\nTired of typing `if (typeof x === 'undefined') x = defaultValue`? Again, ES6\nwill brings us a elegant solution.\n\n# Default values\n\nThe `=` operator can now help to define a default value to a parameter.\n\n## Function parameters\n\nYou can now specify a default value for a parameter of a function.\nThis value will be used if the parameter is not defined, or explicitly set to\n*undefined*.\n\n```js\nfunction incr (value, step = 1) {\n  return value + step\n}\n\nincr(41) // 42\nincr(41, undefined) // 42\nincr(33, 9) // 42\n```\n\n### Dynamic default values\n\nWe can specify an expression as a default value.\nThis expression will be evalued **during the function call**, not during the\nfunction declaration.\n\n```js\nlet defaultWho = 'world!'\nfunction hello (who = defaultWho.toUpperCase()) {\n  return 'Hello ' + who\n}\n\nhello() // 'Hello WORLD!'\ndefaultWho = 'Anyone?'\nhello() // 'Hello ANYONE?'\n```\n\n### Reusing previous parameters\n\nIn the default value expression, you can reuse **previous** function parameters:\n\n```js\nfunction foo (x = 1, y = x + 1) {\n  return x + y\n}\n\nfunction bar (x = y + 1, y = 1) {\n  return x + y\n}\n\nfoo() // 1 + (1 + 1) → 3\nbar() // (undefined + 1) + 1 → NaN\n```\n\n### Particular case: TDZ (Temporal Dead Zone)\n\nA temporal dead zone is an area of your program where a variable exists, but is\nnot available yet while it didn't get its value.\n\nThe following example is obviously invalid:\n\n```js\nfunction foo (x = x) { // throws ReferenceError?\n}\n```\n\nIn fact, during the call of the function, `x` has not been defined yet,\nso it cannot be used as a default value.\nThis example should trigger an\n[error](http://dmitrysoshnikov.com/ecmascript/es6-notes-default-values-of-parameters/#tdz-temporal-dead-zone-for-parameters)\n\nHowever, scope rules will make this example invalid:\n\n```js\nconst x = 1\nfunction foo (x = x) { // 'x' used here is the parameter itself\n}\n```\n\nAfter the evaluation of the default values, we are in the scope of the function\nand in this scope, `x` corresponds to the parameter (not defined yet) and not\nthe value defined above.\n\n**ProTip: do not reuse a variable name 3 times**\n(that might helps to read and understand your code).\n\n## Destructuring\n\nLike for the function arguments, assignments using\n[destructuring](/en/articles/js/es2015/destructuring/)\ncan have a default value.\n\n```js\nconst obj = {z: 42} \nconst { x = 1, y = x + 1, z, w } = obj\nw // undefined\nx // 1\ny // 2\nz // 42\n```\n\nAs a reminder, the assignation in the previous example would have been written\nthis way using ES5:\n\n```js\nvar x = (obj.x === undefined) ? 1 : obj.x \nvar y = (obj.y === undefined) ? x + 1 : obj.y \nvar z = obj.z\nvar w = obj.w\n```\n\n# Enjoy!\n\nThere is no more reasons *a priori* to see an `undefined` in an ES6 codebase.\n\nAbout the compatibility (at the time of the writing): only Firefox ≥ 43\nsupport this feature (and just for function...).\nSo you will need [Babel](http://babeljs.io) or Traceur to be able to use it.\n","raw":"---\ndate: \"2015-12-03\"\ntitle: \"ES6, ES2015: default values for arguments\"\ntags:\n  - javascript\n  - ES6\n  - ES2015\nauthors:\n  - naholyr\ntranslators:\n  - MoOx\n---\n\nTired of typing `if (typeof x === 'undefined') x = defaultValue`? Again, ES6\nwill brings us a elegant solution.\n\n# Default values\n\nThe `=` operator can now help to define a default value to a parameter.\n\n## Function parameters\n\nYou can now specify a default value for a parameter of a function.\nThis value will be used if the parameter is not defined, or explicitly set to\n*undefined*.\n\n```js\nfunction incr (value, step = 1) {\n  return value + step\n}\n\nincr(41) // 42\nincr(41, undefined) // 42\nincr(33, 9) // 42\n```\n\n### Dynamic default values\n\nWe can specify an expression as a default value.\nThis expression will be evalued **during the function call**, not during the\nfunction declaration.\n\n```js\nlet defaultWho = 'world!'\nfunction hello (who = defaultWho.toUpperCase()) {\n  return 'Hello ' + who\n}\n\nhello() // 'Hello WORLD!'\ndefaultWho = 'Anyone?'\nhello() // 'Hello ANYONE?'\n```\n\n### Reusing previous parameters\n\nIn the default value expression, you can reuse **previous** function parameters:\n\n```js\nfunction foo (x = 1, y = x + 1) {\n  return x + y\n}\n\nfunction bar (x = y + 1, y = 1) {\n  return x + y\n}\n\nfoo() // 1 + (1 + 1) → 3\nbar() // (undefined + 1) + 1 → NaN\n```\n\n### Particular case: TDZ (Temporal Dead Zone)\n\nA temporal dead zone is an area of your program where a variable exists, but is\nnot available yet while it didn't get its value.\n\nThe following example is obviously invalid:\n\n```js\nfunction foo (x = x) { // throws ReferenceError?\n}\n```\n\nIn fact, during the call of the function, `x` has not been defined yet,\nso it cannot be used as a default value.\nThis example should trigger an\n[error](http://dmitrysoshnikov.com/ecmascript/es6-notes-default-values-of-parameters/#tdz-temporal-dead-zone-for-parameters)\n\nHowever, scope rules will make this example invalid:\n\n```js\nconst x = 1\nfunction foo (x = x) { // 'x' used here is the parameter itself\n}\n```\n\nAfter the evaluation of the default values, we are in the scope of the function\nand in this scope, `x` corresponds to the parameter (not defined yet) and not\nthe value defined above.\n\n**ProTip: do not reuse a variable name 3 times**\n(that might helps to read and understand your code).\n\n## Destructuring\n\nLike for the function arguments, assignments using\n[destructuring](/en/articles/js/es2015/destructuring/)\ncan have a default value.\n\n```js\nconst obj = {z: 42} \nconst { x = 1, y = x + 1, z, w } = obj\nw // undefined\nx // 1\ny // 2\nz // 42\n```\n\nAs a reminder, the assignation in the previous example would have been written\nthis way using ES5:\n\n```js\nvar x = (obj.x === undefined) ? 1 : obj.x \nvar y = (obj.y === undefined) ? x + 1 : obj.y \nvar z = obj.z\nvar w = obj.w\n```\n\n# Enjoy!\n\nThere is no more reasons *a priori* to see an `undefined` in an ES6 codebase.\n\nAbout the compatibility (at the time of the writing): only Firefox ≥ 43\nsupport this feature (and just for function...).\nSo you will need [Babel](http://babeljs.io) or Traceur to be able to use it.\n","__filename":"en/articles/js/es2015/defaults.md","__url":"/en/articles/js/es2015/defaults/","__resourceUrl":"/en/articles/js/es2015/defaults/index.html","__dataUrl":"/en/articles/js/es2015/defaults/index.html.3c8ce43418304f11b91da9819cedbbfd.json"}