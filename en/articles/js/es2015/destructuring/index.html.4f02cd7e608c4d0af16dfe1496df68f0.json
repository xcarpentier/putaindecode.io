{"head":{"layout":"Post","comments":true,"date":"2015-12-02","title":"ES6, ES2015 : the destructuring","tags":["javascript","ES6","ES2015"],"authors":["bloodyowl"],"translators":["MoOx"],"description":"The destructuring is a feature that helps you assign variables from an object or an array based on their structure. Different syntaxesâ€¦"},"body":"<p>The destructuring is a feature that helps you assign variables from an object or\nan array based on their structure.</p>\n<pre><code class=\"language-js\">// Let's consider this object `myObject`\nvar myObject = {\n  foo: 1,\n  bar: 2,\n}\n\n// With ES5, you need to do\nvar foo = myObject.foo\nvar bar = myObject.bar\n\nfoo // 1\nbar // 2\n\n// With ES6, you can write the same with\nconst { foo, bar } = myObject\nfoo // 1\nbar // 2\n\n// We can even destructure the value returned by a function (if this one\n// returns a function or an array)\nconst getMyObject = function() {\n  return {\n    foo: 1,\n    bar: 2,\n  }\n}\nconst { foo, bar } = getMyObject()\nfoo // 1\nbar // 2\n</code></pre>\n<h2 id=\"different-syntaxes\"><a href=\"#different-syntaxes\"></a>Different syntaxes</h2>\n<h3 id=\"array\"><a href=\"#array\"></a>Array</h3>\n<pre><code class=\"language-js\">// For an array, we can use a syntax that is similar to a literal declaration\n// of an array\n// You might notice that you can ignore an item by just put nothing between the\n// commas\nconst [ first, second, , fourth ] = [1, 2, 3, 4]\nfirst // 1\nsecond // 2\nfourth // 4\n</code></pre>\n<h3 id=\"use-a-different-name-for-the-key\"><a href=\"#use-a-different-name-for-the-key\"></a>Use a different name for the key</h3>\n<p>For an object, the default behavior is that the name of a variable will match\nthe name of the key.\nSo if you have already a variable with this name, you can choose another one.</p>\n<pre><code class=\"language-js\">var myObject = {\n  foo: 1,\n  bar: 2\n}\nconst { foo: renamedFoo } = myObject\nrenamedFoo // 1\n</code></pre>\n<p>This syntax doesn't offer a good readability.</p>\n<h3 id=\"function-arguments\"><a href=\"#function-arguments\"></a>Function arguments</h3>\n<pre><code class=\"language-js\">// We can use destructuring directing in a function declaration\nfunction myFunction({ title, text }) {\n    return title + \": \" + text\n}\n\nmyFunction({ title: \"foo\", text: \"bar\" }) // \"foo: bar\"\n</code></pre>\n<h3 id=\"nested-destructuring\"><a href=\"#nested-destructuring\"></a>Nested destructuring</h3>\n<p>We can also nest the assignments.</p>\n<pre><code class=\"language-js\">var myObject = {\n  foo: {\n    bar: 1,\n  },\n}\nconst { foo: { bar } } = myObject\nbar // 1\n</code></pre>\n<p>Be careful, if the destructuring of the first level should return <code>undefined</code>\n(if the value doesn't exist), be sure that you will have a nesting error, since\na value will try to be retrieved from an <code>undefined</code> property.\nTo prevent this issue, you will need to define\n<a href=\"/en/articles/js/es2015/defaults/\">defaults</a> values.</p>\n","rawBody":"\nThe destructuring is a feature that helps you assign variables from an object or\nan array based on their structure.\n\n```js\n// Let's consider this object `myObject`\nvar myObject = {\n  foo: 1,\n  bar: 2,\n}\n\n// With ES5, you need to do\nvar foo = myObject.foo\nvar bar = myObject.bar\n\nfoo // 1\nbar // 2\n\n// With ES6, you can write the same with\nconst { foo, bar } = myObject\nfoo // 1\nbar // 2\n\n// We can even destructure the value returned by a function (if this one\n// returns a function or an array)\nconst getMyObject = function() {\n  return {\n    foo: 1,\n    bar: 2,\n  }\n}\nconst { foo, bar } = getMyObject()\nfoo // 1\nbar // 2\n```\n\n## Different syntaxes\n\n### Array\n\n```js\n// For an array, we can use a syntax that is similar to a literal declaration\n// of an array\n// You might notice that you can ignore an item by just put nothing between the\n// commas\nconst [ first, second, , fourth ] = [1, 2, 3, 4]\nfirst // 1\nsecond // 2\nfourth // 4\n```\n\n### Use a different name for the key\n\nFor an object, the default behavior is that the name of a variable will match\nthe name of the key.\nSo if you have already a variable with this name, you can choose another one.\n\n```js\nvar myObject = {\n  foo: 1,\n  bar: 2\n}\nconst { foo: renamedFoo } = myObject\nrenamedFoo // 1\n```\n\nThis syntax doesn't offer a good readability.\n\n### Function arguments\n\n```js\n// We can use destructuring directing in a function declaration\nfunction myFunction({ title, text }) {\n\treturn title + \": \" + text\n}\n\nmyFunction({ title: \"foo\", text: \"bar\" }) // \"foo: bar\"\n```\n\n### Nested destructuring\n\nWe can also nest the assignments.\n\n```js\nvar myObject = {\n  foo: {\n    bar: 1,\n  },\n}\nconst { foo: { bar } } = myObject\nbar // 1\n```\n\nBe careful, if the destructuring of the first level should return `undefined`\n(if the value doesn't exist), be sure that you will have a nesting error, since\na value will try to be retrieved from an `undefined` property.\nTo prevent this issue, you will need to define\n[defaults](/en/articles/js/es2015/defaults/) values.\n","raw":"---\ndate: \"2015-12-02\"\ntitle: \"ES6, ES2015 : the destructuring\"\ntags:\n  - javascript\n  - ES6\n  - ES2015\nauthors:\n  - bloodyowl\ntranslators:\n  - MoOx\n---\n\nThe destructuring is a feature that helps you assign variables from an object or\nan array based on their structure.\n\n```js\n// Let's consider this object `myObject`\nvar myObject = {\n  foo: 1,\n  bar: 2,\n}\n\n// With ES5, you need to do\nvar foo = myObject.foo\nvar bar = myObject.bar\n\nfoo // 1\nbar // 2\n\n// With ES6, you can write the same with\nconst { foo, bar } = myObject\nfoo // 1\nbar // 2\n\n// We can even destructure the value returned by a function (if this one\n// returns a function or an array)\nconst getMyObject = function() {\n  return {\n    foo: 1,\n    bar: 2,\n  }\n}\nconst { foo, bar } = getMyObject()\nfoo // 1\nbar // 2\n```\n\n## Different syntaxes\n\n### Array\n\n```js\n// For an array, we can use a syntax that is similar to a literal declaration\n// of an array\n// You might notice that you can ignore an item by just put nothing between the\n// commas\nconst [ first, second, , fourth ] = [1, 2, 3, 4]\nfirst // 1\nsecond // 2\nfourth // 4\n```\n\n### Use a different name for the key\n\nFor an object, the default behavior is that the name of a variable will match\nthe name of the key.\nSo if you have already a variable with this name, you can choose another one.\n\n```js\nvar myObject = {\n  foo: 1,\n  bar: 2\n}\nconst { foo: renamedFoo } = myObject\nrenamedFoo // 1\n```\n\nThis syntax doesn't offer a good readability.\n\n### Function arguments\n\n```js\n// We can use destructuring directing in a function declaration\nfunction myFunction({ title, text }) {\n\treturn title + \": \" + text\n}\n\nmyFunction({ title: \"foo\", text: \"bar\" }) // \"foo: bar\"\n```\n\n### Nested destructuring\n\nWe can also nest the assignments.\n\n```js\nvar myObject = {\n  foo: {\n    bar: 1,\n  },\n}\nconst { foo: { bar } } = myObject\nbar // 1\n```\n\nBe careful, if the destructuring of the first level should return `undefined`\n(if the value doesn't exist), be sure that you will have a nesting error, since\na value will try to be retrieved from an `undefined` property.\nTo prevent this issue, you will need to define\n[defaults](/en/articles/js/es2015/defaults/) values.\n","__filename":"en/articles/js/es2015/destructuring.md","__url":"/en/articles/js/es2015/destructuring/","__resourceUrl":"/en/articles/js/es2015/destructuring/index.html","__dataUrl":"/en/articles/js/es2015/destructuring/index.html.4f02cd7e608c4d0af16dfe1496df68f0.json"}