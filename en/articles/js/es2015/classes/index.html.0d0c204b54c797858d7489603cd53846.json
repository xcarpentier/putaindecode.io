{"head":{"layout":"Post","comments":true,"date":"2015-12-05","title":"ES6, ES2015: Classes","tags":["javascript","ES6","ES2015"],"authors":["magsout"],"translators":["MoOx"],"description":"Classes introduced by ES2015 are just some syntax sugar. They don't really bring anything. That said, this can helps to improve codeâ€¦"},"body":"<p>Classes introduced by ES2015 are just some syntax sugar.\nThey don't really bring anything.\nThat said, this can helps to improve code readability and make the code more\naccessible.</p>\n<h2 id=\"class-declaration\"><a href=\"#class-declaration\"></a>Class declaration</h2>\n<p>Forget functions and prototypes, semantic is taking the relay as you will see in\nthe following example:</p>\n<pre><code class=\"language-js\">class User {\n  constructor(firstname, lastname) {\n    this.firstname = firstname;\n    this.lastname = lastname;\n  }\n\n  sayName() {\n    return `${this.firstname} ${this.lastname}`\n  }\n}\n\n// instantiation\nconst user = new User(\"John\", \"Doe\")\n\n// call of the method sayName()\nconsole.log(user.sayName()) // John Doe\n</code></pre>\n<p>As a reminder, here is one\n<a href=\"https://gist.github.com/magsout/a876b2fa8240a987e523\">way to code</a>\nthis class in <code>ES5</code>:</p>\n<pre><code class=\"language-js\">function User(firstname, lastname) {\n  if(!(this instanceof User)) {\n    throw new TypeError(\"Class constructors cannot be invoked without 'new'\")\n  }\n  this.firstname = firstname\n  this.lastname = lastname\n}\n\nUser.prototype.sayName = function() {\n  return this.firstname + \" \" + this.lastname\n}\n\n// instantiation\nvar user = new User(\"John\", \"Doe\")\n\n// call of the method sayName()\nconsole.log(user.sayName()) // John Doe\n</code></pre>\n<h2 id=\"syntax\"><a href=\"#syntax\"></a>Syntax</h2>\n<p>All methods should be written as simple function inside the class.\nYou might denote the nice way to write getter and setter:</p>\n<pre><code class=\"language-js\">class User {\n  constructor(firstname, lastname, type) {\n    this.firstname = firstname\n    this.lastname = lastname\n    this.type = type\n  }\n\n  // method\n  sayName() {\n   return `${this.firstname}  ${this.lastname}`\n  }\n\n  // getter\n  get role() {\n    return this.type\n  }\n\n  // setter\n  set role(value) {\n    return this.type = value\n  }\n}\n\n// the `new` is mandatory to instantiate a class\nconst user = new User(\"John\", \"Doe\", \"Contributor\")\n\nconsole.log(user.sayName()) // John Doe\nconsole.log(user.role) // Contributor\nuser.role = \"owner\"\nconsole.log(user.role) // Owner\n</code></pre>\n<h2 id=\"inheritance\"><a href=\"#inheritance\"></a>Inheritance</h2>\n<p>In order to have a class that inherits from another, we have the <code>extends</code>\nkeyword.</p>\n<p>Here is the an example:</p>\n<pre><code class=\"language-js\">class Contributor extends User {\n  constructor(firstname, lastname, numberCommit) {\n\n    // keyword `super` is used to call the constructor of the parent class\n    super(firstname, lastname)\n    this.numberCommit = numberCommit\n  }\n\n  sayNameWithCommit() {\n    // we can can also use `super` to call a method of the parent class\n    return super.sayName() + \" \" + this.sayNumberCommit()\n  }\n\n  sayNumberCommit() {\n    return this.numberCommit\n  }\n}\n\nconst contributor = new Contributor('Jane', 'Smith', 10)\n\nconsole.log(contributor.sayName())\nconsole.log(contributor.sayNumberCommit())\n</code></pre>\n<p><strong>Reminder: <a href=\"https://www.youtube.com/watch?v=wfMtDGfHWpA\">prefer inheritance to composition</a>.</strong></p>\n<h2 id=\"thats-it\"><a href=\"#thats-it\"></a>That's it</h2>\n<p>As you saw, all what you can do know was already possible\n<a href=\"https://gist.github.com/bloodyowl/7edc9c973d2236ed17e1\">before</a>.</p>\n<p>We just have a more readable code that should be more easily maintainable.</p>\n<p>For now, you will need to use a transpiler like <a href=\"https://babeljs.io/\">babel</a>\nto be able to use classes.</p>\n<p>One last thing: the bodies of class declarations and class expressions are\nexecuted in\n<a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Strict_mode\">strict mode</a>.</p>\n<pre><code class=\"language-js\">/* Initial strict mode */\nclass MyClass {\n  someMethod() {\n    /* Here we are in strict mode */\n  }\n}\n/* Still the initial strict mode */\n</code></pre>\n","rawBody":"\nClasses introduced by ES2015 are just some syntax sugar.\nThey don't really bring anything.\nThat said, this can helps to improve code readability and make the code more\naccessible.\n\n## Class declaration\n\nForget functions and prototypes, semantic is taking the relay as you will see in\nthe following example:\n\n```js\nclass User {\n  constructor(firstname, lastname) {\n    this.firstname = firstname;\n    this.lastname = lastname;\n  }\n\n  sayName() {\n    return `${this.firstname} ${this.lastname}`\n  }\n}\n\n// instantiation\nconst user = new User(\"John\", \"Doe\")\n\n// call of the method sayName()\nconsole.log(user.sayName()) // John Doe\n```\n\nAs a reminder, here is one\n[way to code](https://gist.github.com/magsout/a876b2fa8240a987e523)\nthis class in `ES5`:\n\n```js\nfunction User(firstname, lastname) {\n  if(!(this instanceof User)) {\n    throw new TypeError(\"Class constructors cannot be invoked without 'new'\")\n  }\n  this.firstname = firstname\n  this.lastname = lastname\n}\n\nUser.prototype.sayName = function() {\n  return this.firstname + \" \" + this.lastname\n}\n\n// instantiation\nvar user = new User(\"John\", \"Doe\")\n\n// call of the method sayName()\nconsole.log(user.sayName()) // John Doe\n```\n\n## Syntax\n\nAll methods should be written as simple function inside the class.\nYou might denote the nice way to write getter and setter:\n\n```js\nclass User {\n  constructor(firstname, lastname, type) {\n    this.firstname = firstname\n    this.lastname = lastname\n    this.type = type\n  }\n\n  // method\n  sayName() {\n   return `${this.firstname}  ${this.lastname}`\n  }\n\n  // getter\n  get role() {\n    return this.type\n  }\n\n  // setter\n  set role(value) {\n    return this.type = value\n  }\n}\n\n// the `new` is mandatory to instantiate a class\nconst user = new User(\"John\", \"Doe\", \"Contributor\")\n\nconsole.log(user.sayName()) // John Doe\nconsole.log(user.role) // Contributor\nuser.role = \"owner\"\nconsole.log(user.role) // Owner\n```\n\n## Inheritance\n\nIn order to have a class that inherits from another, we have the `extends`\nkeyword.\n\nHere is the an example:\n\n```js\nclass Contributor extends User {\n  constructor(firstname, lastname, numberCommit) {\n\n    // keyword `super` is used to call the constructor of the parent class\n    super(firstname, lastname)\n    this.numberCommit = numberCommit\n  }\n\n  sayNameWithCommit() {\n    // we can can also use `super` to call a method of the parent class\n    return super.sayName() + \" \" + this.sayNumberCommit()\n  }\n\n  sayNumberCommit() {\n    return this.numberCommit\n  }\n}\n\nconst contributor = new Contributor('Jane', 'Smith', 10)\n\nconsole.log(contributor.sayName())\nconsole.log(contributor.sayNumberCommit())\n\n```\n\n**Reminder: [prefer inheritance to composition](https://www.youtube.com/watch?v=wfMtDGfHWpA).**\n\n## That's it\n\nAs you saw, all what you can do know was already possible\n[before](https://gist.github.com/bloodyowl/7edc9c973d2236ed17e1).\n\nWe just have a more readable code that should be more easily maintainable.\n\nFor now, you will need to use a transpiler like [babel](https://babeljs.io/)\nto be able to use classes.\n\nOne last thing: the bodies of class declarations and class expressions are\nexecuted in\n[strict mode](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Strict_mode).\n\n```js\n/* Initial strict mode */\nclass MyClass {\n  someMethod() {\n    /* Here we are in strict mode */\n  }\n}\n/* Still the initial strict mode */\n```\n","raw":"---\ndate: \"2015-12-05\"\ntitle: \"ES6, ES2015: Classes\"\ntags:\n  - javascript\n  - ES6\n  - ES2015\nauthors:\n  - magsout\ntranslators:\n  - MoOx\n---\n\nClasses introduced by ES2015 are just some syntax sugar.\nThey don't really bring anything.\nThat said, this can helps to improve code readability and make the code more\naccessible.\n\n## Class declaration\n\nForget functions and prototypes, semantic is taking the relay as you will see in\nthe following example:\n\n```js\nclass User {\n  constructor(firstname, lastname) {\n    this.firstname = firstname;\n    this.lastname = lastname;\n  }\n\n  sayName() {\n    return `${this.firstname} ${this.lastname}`\n  }\n}\n\n// instantiation\nconst user = new User(\"John\", \"Doe\")\n\n// call of the method sayName()\nconsole.log(user.sayName()) // John Doe\n```\n\nAs a reminder, here is one\n[way to code](https://gist.github.com/magsout/a876b2fa8240a987e523)\nthis class in `ES5`:\n\n```js\nfunction User(firstname, lastname) {\n  if(!(this instanceof User)) {\n    throw new TypeError(\"Class constructors cannot be invoked without 'new'\")\n  }\n  this.firstname = firstname\n  this.lastname = lastname\n}\n\nUser.prototype.sayName = function() {\n  return this.firstname + \" \" + this.lastname\n}\n\n// instantiation\nvar user = new User(\"John\", \"Doe\")\n\n// call of the method sayName()\nconsole.log(user.sayName()) // John Doe\n```\n\n## Syntax\n\nAll methods should be written as simple function inside the class.\nYou might denote the nice way to write getter and setter:\n\n```js\nclass User {\n  constructor(firstname, lastname, type) {\n    this.firstname = firstname\n    this.lastname = lastname\n    this.type = type\n  }\n\n  // method\n  sayName() {\n   return `${this.firstname}  ${this.lastname}`\n  }\n\n  // getter\n  get role() {\n    return this.type\n  }\n\n  // setter\n  set role(value) {\n    return this.type = value\n  }\n}\n\n// the `new` is mandatory to instantiate a class\nconst user = new User(\"John\", \"Doe\", \"Contributor\")\n\nconsole.log(user.sayName()) // John Doe\nconsole.log(user.role) // Contributor\nuser.role = \"owner\"\nconsole.log(user.role) // Owner\n```\n\n## Inheritance\n\nIn order to have a class that inherits from another, we have the `extends`\nkeyword.\n\nHere is the an example:\n\n```js\nclass Contributor extends User {\n  constructor(firstname, lastname, numberCommit) {\n\n    // keyword `super` is used to call the constructor of the parent class\n    super(firstname, lastname)\n    this.numberCommit = numberCommit\n  }\n\n  sayNameWithCommit() {\n    // we can can also use `super` to call a method of the parent class\n    return super.sayName() + \" \" + this.sayNumberCommit()\n  }\n\n  sayNumberCommit() {\n    return this.numberCommit\n  }\n}\n\nconst contributor = new Contributor('Jane', 'Smith', 10)\n\nconsole.log(contributor.sayName())\nconsole.log(contributor.sayNumberCommit())\n\n```\n\n**Reminder: [prefer inheritance to composition](https://www.youtube.com/watch?v=wfMtDGfHWpA).**\n\n## That's it\n\nAs you saw, all what you can do know was already possible\n[before](https://gist.github.com/bloodyowl/7edc9c973d2236ed17e1).\n\nWe just have a more readable code that should be more easily maintainable.\n\nFor now, you will need to use a transpiler like [babel](https://babeljs.io/)\nto be able to use classes.\n\nOne last thing: the bodies of class declarations and class expressions are\nexecuted in\n[strict mode](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Strict_mode).\n\n```js\n/* Initial strict mode */\nclass MyClass {\n  someMethod() {\n    /* Here we are in strict mode */\n  }\n}\n/* Still the initial strict mode */\n```\n","__filename":"en/articles/js/es2015/classes.md","__url":"/en/articles/js/es2015/classes/","__resourceUrl":"/en/articles/js/es2015/classes/index.html","__dataUrl":"/en/articles/js/es2015/classes/index.html.0d0c204b54c797858d7489603cd53846.json"}